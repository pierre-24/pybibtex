{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>pybibtex</code>: a (very) simple BibTeX parser","text":"<p>Provides a Python API to parse BibTeX files. Not to be confused with the (actual) <code>pybibtex</code>: while this implementation is a more clever approach (this is actual syntax parsing, not REGEX).</p> <p>The BiBTeX syntax is introduced, simply, there. More details are found in <code>btxdoc</code> (and some of its quirks are examplified here). This implementation handles the different syntax for the items (braces or parentheses), the comments, and the concatenation (with the <code>@string</code> definitions). It does not handle <code>@preamble</code>.</p>"},{"location":"#install-use","title":"Install &amp; use","text":"<pre><code>pip3 install --upgrade git+https://github.com/pierre-24/pybibtex.git@v0.2.0\n</code></pre> <p>No dependencies are required (except python &gt;= 3.6).</p> <p>See the documentation there demonstrating the (quite simple) API.</p>"},{"location":"#contribute","title":"Contribute","text":"<p>Contributions, either with issues or pull requests are welcomed. See the Contributing section of the documentation for more details.</p>"},{"location":"contributing/","title":"Install and contribute","text":"<p>If you want to contribute, this is the usual deal: </p> <ol> <li>Start by forking, then clone your fork   <pre><code>git clone git@github.com:&lt;YOUR_USERNAME&gt;/pybibtex.git\ncd pybibtex\n</code></pre></li> <li>Then setup... And you are good to go :)   <pre><code>python -m venv venv # a virtualenv is always a good idea\nsource venv/bin/activate\nmake install # install what's needed for dev\n</code></pre></li> </ol>"},{"location":"contributing/#tips-to-contribute","title":"Tips to contribute","text":"<ul> <li> <p>A good place to start is the list of issues.   In fact, it is easier if you start by filling an issue, and if you want to work on it, says so there, so that everyone knows that the issue is handled.</p> </li> <li> <p>Don't forget to work on a separate branch: you should base your branch on <code>master</code>, not work in it directly:</p> <pre><code>git checkout -b new_branch origin/master\n</code></pre> </li> <li> <p>Don't forget to regularly run the linting and tests:</p> <pre><code>make lint\nmake test\n</code></pre> <p>Indeed, the code follows the PEP-8 style recommendations, checked by <code>flake8</code>, for the python part and use <code>jshint</code> for the JS part. Having an extensive test suite is also a good idea to prevent regressions.</p> </li> <li> <p>If you want to see and edit the doc, you can run the <code>mkdocs</code> webserver:</p> <pre><code>make doc-serve\n</code></pre> </li> <li> <p>Pull requests should be unitary, and include unit test(s) and documentation if needed.    The test suite and lint must succeed for the merge request to be accepted.</p> </li> </ul>"},{"location":"usage/","title":"Usage","text":"<p>Here are 3 example of the usage you can have of <code>pybibtex</code>.</p>"},{"location":"usage/#import-and-use-bibliography","title":"Import and use bibliography","text":"<p>Say you want to import this BibTeX file, stored in <code>example.bib</code>.</p> <pre><code>@string(bibtex = \"BiB{\\TeX}\")\n\n@comment that's a comment\n@misc{bibtexing,\nauthor = \"Oren Patashnik\",\ntitle = bibtex # \"ing\",\nyear = 1988,\nurl = {https://www.ctan.org/tex-archive/biblio/bibtex/contrib/doc/}\n}\n\nYes, between items, you can write whatever you want!\n</code></pre> <p>You can import this bibliography using</p> <pre><code>from pybibtex.parser import Parser\n\nwith open('test.bib') as bibfile:\n    database = Parser(bibfile.read()).parse()\n</code></pre> <p>You can check and access the items via their citation key:</p> <pre><code>assert 'bibtexing' in database\nitem = database['bibtexing']\n</code></pre> <p>Note that per BibTeX specification, the citation key is case insensitive, so that the following code results in the same item:</p> <pre><code>item = database['BiBTEXing']\n</code></pre> <p>A bibliography item contains the different fields, which are directly addressable:</p> <pre><code>assert 'title' in item\nprint(item['title'])\nprint(item['year'])\n</code></pre> <p>This results in</p> <pre><code>Bib\\TeXing\n1988\n</code></pre> <p>The first line demonstrate the concatenation at line 7 of test.bib.  You can access the citation key with <code>item.cite_key</code> and the item type with <code>item.item_type</code>.</p>"},{"location":"usage/#get-authors","title":"Get authors","text":"<p><code>pybibtex</code> provides a convenient API to extract the authors.</p> <p>One way to use it is</p> <pre><code>from pybibtex.authors import AuthorsParser\nauthors = AuthorsParser(\n    'Pierre Beaujean and de la Fontaine, Jean').authors()\n</code></pre> <p>But you can also access the author of a bibliography item with this specific function:</p> <pre><code>authors = item.authors()\n</code></pre> <p>Both methods return a list of <code>Author</code>. You can then access</p> <ul> <li>its last name, with <code>author.last</code> (always not empty),</li> <li>its first name, with <code>author.first</code> (may be empty),</li> <li>its \"von\" part, with <code>author.von</code> (may be empty),</li> <li>its \"jr\" part, with <code>author.jr</code> (may be empty).</li> </ul>"},{"location":"usage/#convert-accentuated-strings","title":"Convert accentuated strings","text":"<p>LaTeX is notoriously (in)famous for its way to handle UTF-8 characters. You can convert a string to this format using</p> <pre><code>from pybibtex.latexutf8 import utf8decode\nprint(utf8decode('\u00c9mile de la Tourbi\u00e8re'))\n</code></pre> <p>which outputs:</p> <pre><code>\\'Emile de la Tourbi\\`ere\n</code></pre> <p>The converse is obtained with:</p> <pre><code>from pybibtex.latexutf8 import utf8encode\nprint(utf8encode(\"\\\\'Emile de la Tourbi\\\\`ere\"))\n</code></pre>"},{"location":"code_reference/authors/","title":"Authors","text":"<p>Example of usage:</p> <pre><code>from pybibtex.authors import AuthorsParser\n\nauthors = AuthorsParser(\n    'Pierre Beaujean and de la Fontaine, Jean').authors()\n\nassert len(authors) == 2\n\nprint(authors[0].last)  # prints \"Beaujean\"\nprint(\n    authors[1].first,\n    authors[1].von, \n    authors[1].last)  # prints \"Jean de la Fontaine\"\n</code></pre>"},{"location":"code_reference/authors/#pybibtex.authors.Author","title":"<code>Author</code>","text":"<p>Represent an author</p> <p>You can access:</p> <ul> <li>its last name, with <code>author.last</code> (always not empty),</li> <li>its first name, with <code>author.first</code> (may be empty),</li> <li>its \"von\" part, with <code>author.von</code> (may be empty),</li> <li>its \"jr\" part, with <code>author.jr</code> (may be empty).</li> </ul> Source code in <code>pybibtex/authors.py</code> <pre><code>class Author:\n\"\"\"Represent an author\n\n    You can access:\n\n    + its last name, with `author.last` (always not empty),\n    + its first name, with `author.first` (may be empty),\n    + its \"von\" part, with `author.von` (may be empty),\n    + its \"jr\" part, with `author.jr` (may be empty).\n    \"\"\"\n\n    def __init__(self, first: str, last: str, von: str = '', jr: str = ''):\n\"\"\"Initialize the object\n        \"\"\"\n        if not last:\n            raise Exception('last must not be empty')\n\n        self.first = first  #: author first name (may be empty)\n        self.last = last  #: author last name (never empty)\n        self.von = von  #: author \"von\" part (may be empty)\n        self.jr = jr  #: author \"jr\" part (may be empty)\n\n    def __str__(self):\n\"\"\"Return the author in the \"comma\" form (since it is the only one which handle \"jr\")\n        \"\"\"\n\n        return '{}{}, {}{}'.format(\n            '' if not self.von else self.von + ' ',\n            self.last,\n            '' if not self.jr else '{}, '.format(self.jr),\n            self.first\n        )\n\n    def __repr__(self):\n        return \"Author('{}', '{}'{}{})\".format(\n            self.first,\n            self.last,\n            '' if not self.von else \", von='{}'\".format(self.von),\n            '' if not self.jr else \", jr='{}'\".format(self.jr)\n        )\n\n    def __eq__(self, other: 'Author'):\n        if type(other) is not Author:\n            return False\n\n        return self.first == other.first and self.last == other.last and self.jr == other.jr and self.von == other.von\n</code></pre>"},{"location":"code_reference/authors/#pybibtex.authors.Author.__init__","title":"<code>__init__(first, last, von='', jr='')</code>","text":"<p>Initialize the object</p> Source code in <code>pybibtex/authors.py</code> <pre><code>def __init__(self, first: str, last: str, von: str = '', jr: str = ''):\n\"\"\"Initialize the object\n    \"\"\"\n    if not last:\n        raise Exception('last must not be empty')\n\n    self.first = first  #: author first name (may be empty)\n    self.last = last  #: author last name (never empty)\n    self.von = von  #: author \"von\" part (may be empty)\n    self.jr = jr  #: author \"jr\" part (may be empty)\n</code></pre>"},{"location":"code_reference/authors/#pybibtex.authors.Author.__str__","title":"<code>__str__()</code>","text":"<p>Return the author in the \"comma\" form (since it is the only one which handle \"jr\")</p> Source code in <code>pybibtex/authors.py</code> <pre><code>def __str__(self):\n\"\"\"Return the author in the \"comma\" form (since it is the only one which handle \"jr\")\n    \"\"\"\n\n    return '{}{}, {}{}'.format(\n        '' if not self.von else self.von + ' ',\n        self.last,\n        '' if not self.jr else '{}, '.format(self.jr),\n        self.first\n    )\n</code></pre>"},{"location":"code_reference/authors/#pybibtex.authors.AuthorParserSyntaxError","title":"<code>AuthorParserSyntaxError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Exception raised when the parser issued an error</p> Source code in <code>pybibtex/authors.py</code> <pre><code>class AuthorParserSyntaxError(Exception):\n\"\"\"Exception raised when the parser issued an error\"\"\"\n    pass\n</code></pre>"},{"location":"code_reference/authors/#pybibtex.authors.AuthorToken","title":"<code>AuthorToken</code>","text":"Source code in <code>pybibtex/authors.py</code> <pre><code>class AuthorToken:\n    def __init__(self, typ_: AuthorTokenType, value: str, position: int = -1):\n\"\"\"Initialize the object\n        \"\"\"\n        self.type = typ_\n        self.value = value\n        self.position = position\n\n    def __repr__(self):\n        return \"Token({}, '{}'{})\".format(\n            self.type,\n            self.value,\n            '' if self.position &lt; 0 else ', {}'.format(self.position)\n        )\n</code></pre>"},{"location":"code_reference/authors/#pybibtex.authors.AuthorToken.__init__","title":"<code>__init__(typ_, value, position=-1)</code>","text":"<p>Initialize the object</p> Source code in <code>pybibtex/authors.py</code> <pre><code>def __init__(self, typ_: AuthorTokenType, value: str, position: int = -1):\n\"\"\"Initialize the object\n    \"\"\"\n    self.type = typ_\n    self.value = value\n    self.position = position\n</code></pre>"},{"location":"code_reference/authors/#pybibtex.authors.AuthorsParser","title":"<code>AuthorsParser</code>","text":"<p>Parser to extract the authors</p> Source code in <code>pybibtex/authors.py</code> <pre><code>class AuthorsParser:\n\"\"\"Parser to extract the authors\n    \"\"\"\n\n    def __init__(self, inp: str):\n\"\"\"Initialize the object\n\n        Parameters:\n            inp: input string\n        \"\"\"\n        self.input = inp\n        self.current_token: AuthorToken = None\n        self.tokenizer = self.tokenize()\n\n        self.next()\n\n    def next(self):\n\"\"\"Go to next token\n        \"\"\"\n\n        try:\n            self.current_token = next(self.tokenizer)\n        except StopIteration:\n            self.current_token = AuthorToken(AuthorTokenType.EOS, '\\0')\n\n    def eat(self, typ: AuthorTokenType):\n        if self.current_token.type == typ:\n            self.next()\n        else:\n            raise AuthorParserSyntaxError('expected {}, got {}'.format(typ, self.current_token))\n\n    def tokenize(self) -&gt; Iterator[AuthorToken]:\n        i = 0\n        while i &lt; len(self.input):\n            current_char = self.input[i]\n            if current_char in AUTHOR_SYMBOL_TR:\n                yield AuthorToken(AUTHOR_SYMBOL_TR[current_char], current_char, i)\n            elif current_char == '{':\n                j = i + 1\n                is_special = False\n                opening_level = 1\n                while j &lt; len(self.input):\n                    cc = self.input[j]\n                    if j == i + 1 and cc == '\\\\':\n                        is_special = True\n                    if cc == '{':\n                        opening_level += 1\n                    elif cc == '}':\n                        opening_level -= 1\n                        if opening_level == 0:\n                            break\n                    j += 1\n                if opening_level != 0:\n                    raise AuthorParserSyntaxError('unmatched braces while EOS!')\n                else:\n                    yield AuthorToken(\n                        AuthorTokenType.BRACEDITEM if not is_special else AuthorTokenType.SPECIALCHAR,\n                        self.input[i:j + 1],\n                        i)\n                    i = j\n            else:\n                yield AuthorToken(AuthorTokenType.LETTER, current_char, i)\n\n            i += 1\n\n        yield AuthorToken(AuthorTokenType.EOS, '\\0', i)\n\n    def skip_empty(self):\n\"\"\"Skip spaces\n        \"\"\"\n\n        while self.current_token.type == AuthorTokenType.SPACE:\n            self.next()\n\n    def authors(self) -&gt; List[Author]:\n\"\"\"Get the list of `Author`\n        \"\"\"\n\n        return [s.transform() for s in self.sequences()]\n\n    def sequences(self) -&gt; List[WordSequence]:\n\"\"\"Get a list of word sequences (either pure or comma separated) separated by \"and\"\n\n\n        ```text\n        spaces := SPACE SPACE* ;\n        words := word (spaces word)*\n        comma_sep_seq :=\n            words spaces? COMMA spaces? words (spaces? COMMA spaces? words)* ;\n        pure_seq := words\n        sequence := pure_seq\n                 | comma_sep_seq\n                 ;\n        sequences := sequence (\"and\" sequence)* ;\n        ```\n        \"\"\"\n\n        sequences: List[WordSequence] = []\n        words = [[]]\n        capitalizations = [[]]\n        group = 0\n\n        def make_seq():\n            if group == 0:\n                sequences.append(PureWordSequence(words[0], capitalizations[0]))\n            else:\n                sequences.append(CommaSeparatedWordSequence(words, capitalizations))\n\n        self.skip_empty()\n        while self.current_token.type != AuthorTokenType.EOS:\n            if self.current_token.type in [\n                AuthorTokenType.LETTER, AuthorTokenType.BRACEDITEM, AuthorTokenType.SPECIALCHAR\n            ]:\n                word, capitalization = self.word()\n\n                if word.lower() == 'and':\n                    make_seq()\n                    group = 0\n                    words = [[]]\n                    capitalizations = [[]]\n                else:\n                    words[group].append(word)\n                    capitalizations[group].append(capitalization)\n                self.skip_empty()\n            elif self.current_token.type == AuthorTokenType.COMMA:\n                group += 1\n                if group &gt; 3:\n                    raise AuthorParserSyntaxError(\n                        'got {}, which is more than 2 comma!'.format(self.current_token))\n                words.append([])\n                capitalizations.append([])\n\n                self.next()\n                self.skip_empty()\n\n        # catch last\n        make_seq()\n\n        return sequences\n\n    def word(self) -&gt; Tuple[str, int]:\n\"\"\"Get a word and its capitalization,\n        according to http://tug.ctan.org/info/bibtex/tamethebeast/ttb_en.pdf:\n\n        + ``-1`` if the word is caseless,\n        + ``0`` if it is lowercase,\n        + ``1`` if it is uppercase\n\n        A ``BRACEDITEM`` has no case, but a special character has the one of its argument\n\n        ```text\n        c := LETTER\n          | BRACEDITEM\n          | SPECIALCHAR\n          ;\n\n        word := c c* ;\n        ```\n        \"\"\"\n\n        check_capitalization = True\n        capitalization = -1\n        word = ''\n        while self.current_token.type in [\n            AuthorTokenType.LETTER, AuthorTokenType.BRACEDITEM, AuthorTokenType.SPECIALCHAR\n        ]:\n            value = self.current_token.value\n            if check_capitalization:\n                if self.current_token.type == AuthorTokenType.LETTER and value.isalpha():\n                    capitalization = 1 if value.upper() == value else 0\n                    check_capitalization = False\n                elif self.current_token.type == AuthorTokenType.SPECIALCHAR:\n                    # quick and dirty look for argument\n                    i = 2\n\n                    # skip command name\n                    if value[i].isalpha():\n                        while i &lt; len(value) and value[i].isalpha():\n                            i += 1\n\n                    # take next alpha (should be the argument)\n                    while i &lt; len(value) and not value[i].isalnum():\n                        i += 1\n\n                    if i &lt; len(value):\n                        capitalization = 1 if value[i].upper() == value[i] else 0\n                        check_capitalization = False\n\n            word += value\n            self.next()\n\n        return word, capitalization\n</code></pre>"},{"location":"code_reference/authors/#pybibtex.authors.AuthorsParser.__init__","title":"<code>__init__(inp)</code>","text":"<p>Initialize the object</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>input string</p> required Source code in <code>pybibtex/authors.py</code> <pre><code>def __init__(self, inp: str):\n\"\"\"Initialize the object\n\n    Parameters:\n        inp: input string\n    \"\"\"\n    self.input = inp\n    self.current_token: AuthorToken = None\n    self.tokenizer = self.tokenize()\n\n    self.next()\n</code></pre>"},{"location":"code_reference/authors/#pybibtex.authors.AuthorsParser.authors","title":"<code>authors()</code>","text":"<p>Get the list of <code>Author</code></p> Source code in <code>pybibtex/authors.py</code> <pre><code>def authors(self) -&gt; List[Author]:\n\"\"\"Get the list of `Author`\n    \"\"\"\n\n    return [s.transform() for s in self.sequences()]\n</code></pre>"},{"location":"code_reference/authors/#pybibtex.authors.AuthorsParser.next","title":"<code>next()</code>","text":"<p>Go to next token</p> Source code in <code>pybibtex/authors.py</code> <pre><code>def next(self):\n\"\"\"Go to next token\n    \"\"\"\n\n    try:\n        self.current_token = next(self.tokenizer)\n    except StopIteration:\n        self.current_token = AuthorToken(AuthorTokenType.EOS, '\\0')\n</code></pre>"},{"location":"code_reference/authors/#pybibtex.authors.AuthorsParser.sequences","title":"<code>sequences()</code>","text":"<p>Get a list of word sequences (either pure or comma separated) separated by \"and\"</p> <pre><code>spaces := SPACE SPACE* ;\nwords := word (spaces word)*\ncomma_sep_seq :=\n    words spaces? COMMA spaces? words (spaces? COMMA spaces? words)* ;\npure_seq := words\nsequence := pure_seq\n         | comma_sep_seq\n         ;\nsequences := sequence (\"and\" sequence)* ;\n</code></pre> Source code in <code>pybibtex/authors.py</code> <pre><code>def sequences(self) -&gt; List[WordSequence]:\n\"\"\"Get a list of word sequences (either pure or comma separated) separated by \"and\"\n\n\n    ```text\n    spaces := SPACE SPACE* ;\n    words := word (spaces word)*\n    comma_sep_seq :=\n        words spaces? COMMA spaces? words (spaces? COMMA spaces? words)* ;\n    pure_seq := words\n    sequence := pure_seq\n             | comma_sep_seq\n             ;\n    sequences := sequence (\"and\" sequence)* ;\n    ```\n    \"\"\"\n\n    sequences: List[WordSequence] = []\n    words = [[]]\n    capitalizations = [[]]\n    group = 0\n\n    def make_seq():\n        if group == 0:\n            sequences.append(PureWordSequence(words[0], capitalizations[0]))\n        else:\n            sequences.append(CommaSeparatedWordSequence(words, capitalizations))\n\n    self.skip_empty()\n    while self.current_token.type != AuthorTokenType.EOS:\n        if self.current_token.type in [\n            AuthorTokenType.LETTER, AuthorTokenType.BRACEDITEM, AuthorTokenType.SPECIALCHAR\n        ]:\n            word, capitalization = self.word()\n\n            if word.lower() == 'and':\n                make_seq()\n                group = 0\n                words = [[]]\n                capitalizations = [[]]\n            else:\n                words[group].append(word)\n                capitalizations[group].append(capitalization)\n            self.skip_empty()\n        elif self.current_token.type == AuthorTokenType.COMMA:\n            group += 1\n            if group &gt; 3:\n                raise AuthorParserSyntaxError(\n                    'got {}, which is more than 2 comma!'.format(self.current_token))\n            words.append([])\n            capitalizations.append([])\n\n            self.next()\n            self.skip_empty()\n\n    # catch last\n    make_seq()\n\n    return sequences\n</code></pre>"},{"location":"code_reference/authors/#pybibtex.authors.AuthorsParser.skip_empty","title":"<code>skip_empty()</code>","text":"<p>Skip spaces</p> Source code in <code>pybibtex/authors.py</code> <pre><code>def skip_empty(self):\n\"\"\"Skip spaces\n    \"\"\"\n\n    while self.current_token.type == AuthorTokenType.SPACE:\n        self.next()\n</code></pre>"},{"location":"code_reference/authors/#pybibtex.authors.AuthorsParser.word","title":"<code>word()</code>","text":"<p>Get a word and its capitalization, according to http://tug.ctan.org/info/bibtex/tamethebeast/ttb_en.pdf:</p> <ul> <li><code>-1</code> if the word is caseless,</li> <li><code>0</code> if it is lowercase,</li> <li><code>1</code> if it is uppercase</li> </ul> <p>A <code>BRACEDITEM</code> has no case, but a special character has the one of its argument</p> <pre><code>c := LETTER\n  | BRACEDITEM\n  | SPECIALCHAR\n  ;\n\nword := c c* ;\n</code></pre> Source code in <code>pybibtex/authors.py</code> <pre><code>def word(self) -&gt; Tuple[str, int]:\n\"\"\"Get a word and its capitalization,\n    according to http://tug.ctan.org/info/bibtex/tamethebeast/ttb_en.pdf:\n\n    + ``-1`` if the word is caseless,\n    + ``0`` if it is lowercase,\n    + ``1`` if it is uppercase\n\n    A ``BRACEDITEM`` has no case, but a special character has the one of its argument\n\n    ```text\n    c := LETTER\n      | BRACEDITEM\n      | SPECIALCHAR\n      ;\n\n    word := c c* ;\n    ```\n    \"\"\"\n\n    check_capitalization = True\n    capitalization = -1\n    word = ''\n    while self.current_token.type in [\n        AuthorTokenType.LETTER, AuthorTokenType.BRACEDITEM, AuthorTokenType.SPECIALCHAR\n    ]:\n        value = self.current_token.value\n        if check_capitalization:\n            if self.current_token.type == AuthorTokenType.LETTER and value.isalpha():\n                capitalization = 1 if value.upper() == value else 0\n                check_capitalization = False\n            elif self.current_token.type == AuthorTokenType.SPECIALCHAR:\n                # quick and dirty look for argument\n                i = 2\n\n                # skip command name\n                if value[i].isalpha():\n                    while i &lt; len(value) and value[i].isalpha():\n                        i += 1\n\n                # take next alpha (should be the argument)\n                while i &lt; len(value) and not value[i].isalnum():\n                    i += 1\n\n                if i &lt; len(value):\n                    capitalization = 1 if value[i].upper() == value[i] else 0\n                    check_capitalization = False\n\n        word += value\n        self.next()\n\n    return word, capitalization\n</code></pre>"},{"location":"code_reference/authors/#pybibtex.authors.CommaSeparatedWordSequence","title":"<code>CommaSeparatedWordSequence</code>","text":"<p>         Bases: <code>WordSequence</code></p> Source code in <code>pybibtex/authors.py</code> <pre><code>class CommaSeparatedWordSequence(WordSequence):\n    def __init__(self, seq: List[List[str]], capitalization: List[List[int]]):\n\"\"\"Initialize the object\n        \"\"\"\n        self.groups = seq\n        self.num_fields = len(self.groups)\n\n        self.capitalizations = capitalization\n\n    def transform(self) -&gt; Author:\n\"\"\"Transform a sequence written in \"comma form\" into an author:\n\n        1. The last group is always `first`;\n        2. If they are 3 groups, the second is `jr`;\n        2. Put the last word of the first group in `last`.\n           Then, as long as they are uppercase or caseless, the last words of the first group\n           are in `last` (stops at the first lowercase one);\n        3. The remaining of the first group is in `von`;\n        \"\"\"\n\n        first = WordSequence.to_sentence(self.groups[-1])\n        jr = '' if self.num_fields == 2 else WordSequence.to_sentence(self.groups[-2])\n\n        words = self.groups[0]\n        capitalizations = self.capitalizations[0]\n\n        start_last = len(words) - 1\n\n        while start_last &gt; 0:\n            if capitalizations[start_last - 1] in [1, -1]:\n                start_last -= 1\n            else:\n                break\n\n        last = WordSequence.to_sentence(words[start_last:])\n\n        if start_last &gt; 0:\n            von = ' '.join(words[:start_last])\n        else:\n            von = ''\n\n        return Author(first, last, von=von, jr=jr)\n</code></pre>"},{"location":"code_reference/authors/#pybibtex.authors.CommaSeparatedWordSequence.__init__","title":"<code>__init__(seq, capitalization)</code>","text":"<p>Initialize the object</p> Source code in <code>pybibtex/authors.py</code> <pre><code>def __init__(self, seq: List[List[str]], capitalization: List[List[int]]):\n\"\"\"Initialize the object\n    \"\"\"\n    self.groups = seq\n    self.num_fields = len(self.groups)\n\n    self.capitalizations = capitalization\n</code></pre>"},{"location":"code_reference/authors/#pybibtex.authors.CommaSeparatedWordSequence.transform","title":"<code>transform()</code>","text":"<p>Transform a sequence written in \"comma form\" into an author:</p> <ol> <li>The last group is always <code>first</code>;</li> <li>If they are 3 groups, the second is <code>jr</code>;</li> <li>Put the last word of the first group in <code>last</code>.    Then, as long as they are uppercase or caseless, the last words of the first group    are in <code>last</code> (stops at the first lowercase one);</li> <li>The remaining of the first group is in <code>von</code>;</li> </ol> Source code in <code>pybibtex/authors.py</code> <pre><code>def transform(self) -&gt; Author:\n\"\"\"Transform a sequence written in \"comma form\" into an author:\n\n    1. The last group is always `first`;\n    2. If they are 3 groups, the second is `jr`;\n    2. Put the last word of the first group in `last`.\n       Then, as long as they are uppercase or caseless, the last words of the first group\n       are in `last` (stops at the first lowercase one);\n    3. The remaining of the first group is in `von`;\n    \"\"\"\n\n    first = WordSequence.to_sentence(self.groups[-1])\n    jr = '' if self.num_fields == 2 else WordSequence.to_sentence(self.groups[-2])\n\n    words = self.groups[0]\n    capitalizations = self.capitalizations[0]\n\n    start_last = len(words) - 1\n\n    while start_last &gt; 0:\n        if capitalizations[start_last - 1] in [1, -1]:\n            start_last -= 1\n        else:\n            break\n\n    last = WordSequence.to_sentence(words[start_last:])\n\n    if start_last &gt; 0:\n        von = ' '.join(words[:start_last])\n    else:\n        von = ''\n\n    return Author(first, last, von=von, jr=jr)\n</code></pre>"},{"location":"code_reference/authors/#pybibtex.authors.PureWordSequence","title":"<code>PureWordSequence</code>","text":"<p>         Bases: <code>WordSequence</code></p> Source code in <code>pybibtex/authors.py</code> <pre><code>class PureWordSequence(WordSequence):\n    def __init__(self, words: List[str], capitalization: List[int]):\n\"\"\"Initialize the object\n        \"\"\"\n        self.words = words\n        self.capitalizations = capitalization\n\n    def transform(self) -&gt; Author:\n\"\"\"Transform a sequence written in \"natural form\" (no comma) into an author:\n\n        1. The last word is always `last`;\n        2. As long as they are uppercase or caseless, the first words are in `first`\n           (stops at the first lowercase one);\n        3. The remaining is in `von`;\n        4. There is no `jr` part.\n        \"\"\"\n\n        von = ''\n        jr = ''\n        words = self.words\n\n        # get first\n        end_first = 0\n        while end_first &lt; len(words) - 1:\n            if self.capitalizations[end_first] in [1, -1]:\n                end_first += 1\n            else:\n                break\n\n        first = WordSequence.to_sentence(words[:end_first])\n\n        # get last\n        start_last = len(words) - 1\n\n        while start_last &gt; end_first:\n            if self.capitalizations[start_last - 1] in [1, -1]:\n                start_last -= 1\n            else:\n                break\n\n        last = WordSequence.to_sentence(words[start_last:])\n\n        # get von, if any\n        if end_first != start_last:\n            von = WordSequence.to_sentence(words[end_first:start_last])\n\n        return Author(first, last, von=von, jr=jr)\n</code></pre>"},{"location":"code_reference/authors/#pybibtex.authors.PureWordSequence.__init__","title":"<code>__init__(words, capitalization)</code>","text":"<p>Initialize the object</p> Source code in <code>pybibtex/authors.py</code> <pre><code>def __init__(self, words: List[str], capitalization: List[int]):\n\"\"\"Initialize the object\n    \"\"\"\n    self.words = words\n    self.capitalizations = capitalization\n</code></pre>"},{"location":"code_reference/authors/#pybibtex.authors.PureWordSequence.transform","title":"<code>transform()</code>","text":"<p>Transform a sequence written in \"natural form\" (no comma) into an author:</p> <ol> <li>The last word is always <code>last</code>;</li> <li>As long as they are uppercase or caseless, the first words are in <code>first</code>    (stops at the first lowercase one);</li> <li>The remaining is in <code>von</code>;</li> <li>There is no <code>jr</code> part.</li> </ol> Source code in <code>pybibtex/authors.py</code> <pre><code>def transform(self) -&gt; Author:\n\"\"\"Transform a sequence written in \"natural form\" (no comma) into an author:\n\n    1. The last word is always `last`;\n    2. As long as they are uppercase or caseless, the first words are in `first`\n       (stops at the first lowercase one);\n    3. The remaining is in `von`;\n    4. There is no `jr` part.\n    \"\"\"\n\n    von = ''\n    jr = ''\n    words = self.words\n\n    # get first\n    end_first = 0\n    while end_first &lt; len(words) - 1:\n        if self.capitalizations[end_first] in [1, -1]:\n            end_first += 1\n        else:\n            break\n\n    first = WordSequence.to_sentence(words[:end_first])\n\n    # get last\n    start_last = len(words) - 1\n\n    while start_last &gt; end_first:\n        if self.capitalizations[start_last - 1] in [1, -1]:\n            start_last -= 1\n        else:\n            break\n\n    last = WordSequence.to_sentence(words[start_last:])\n\n    # get von, if any\n    if end_first != start_last:\n        von = WordSequence.to_sentence(words[end_first:start_last])\n\n    return Author(first, last, von=von, jr=jr)\n</code></pre>"},{"location":"code_reference/authors/#pybibtex.authors.WordSequence","title":"<code>WordSequence</code>","text":"Source code in <code>pybibtex/authors.py</code> <pre><code>class WordSequence:\n    def transform(self) -&gt; Author:\n\"\"\"Transform the word sequence into an author\n        \"\"\"\n\n        raise NotImplementedError()\n\n    @staticmethod\n    def to_sentence(seq: List[str], sep: str = ' ') -&gt; str:\n        return sep.join(seq)\n</code></pre>"},{"location":"code_reference/authors/#pybibtex.authors.WordSequence.transform","title":"<code>transform()</code>","text":"<p>Transform the word sequence into an author</p> Source code in <code>pybibtex/authors.py</code> <pre><code>def transform(self) -&gt; Author:\n\"\"\"Transform the word sequence into an author\n    \"\"\"\n\n    raise NotImplementedError()\n</code></pre>"},{"location":"code_reference/bibliography/","title":"Bibliography","text":"<p>Example of usage:</p> <pre><code>from pybibtex.parser import Parser\n\nbibtex = \"\"\"\n@string(bibtex = \"BiB{\\TeX}\")\n@misc{bibtexing,\n   author = \"Oren Patashnik\",\n   title = bibtex # \"ing\",\n   year = 1988\n}\n\"\"\"\n\ndatabase = Parser(bibtex).parse()\n\nitem = database['bibtexing']\n\nprint(item['title'])  # prints \"BiB{\\TeX}ing\nprint(item['year'])  # prints 1988\n</code></pre>"},{"location":"code_reference/bibliography/#pybibtex.bibliography.Database","title":"<code>Database</code>","text":"<p>Database of bibliographic items</p> <p>You can access the item directly by their citation key using <code>bibliography['citation-key']</code>.</p> <p>Note</p> <p>The <code>cite_key</code> are considered to be case insensitive in lookup.</p> Source code in <code>pybibtex/bibliography.py</code> <pre><code>class Database:\n\"\"\"Database of bibliographic items\n\n    You can access the item directly by their citation key using ``bibliography['citation-key']``.\n\n    !!! note\n        The `cite_key` are considered to be case insensitive in lookup.\n    \"\"\"\n\n    def __init__(self, db: Dict[str, Item] = None):\n        self.db = {} if db is None else db\n\n    def __getitem__(self, item: str) -&gt; Item:\n        return self.db[item.lower()]\n\n    def __contains__(self, item) -&gt; bool:\n        return item.lower() in self.db\n\n    def __iter__(self) -&gt; Iterable[str]:\n        yield from self.db\n\n    def iter_item(self) -&gt; Iterable[Item]:\n        yield from self.db.values()\n\n    def __repr__(self):\n        return ', '.join('@{}({})'.format(i.item_type, i.cite_key) for i in self.db.values())\n\n    def __str__(self) -&gt; str:\n\"\"\"Outputs bibtex database\n        \"\"\"\n\n        return '\\n'.join(str(item) for item in self.db.values())\n</code></pre>"},{"location":"code_reference/bibliography/#pybibtex.bibliography.Database.__str__","title":"<code>__str__()</code>","text":"<p>Outputs bibtex database</p> Source code in <code>pybibtex/bibliography.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Outputs bibtex database\n    \"\"\"\n\n    return '\\n'.join(str(item) for item in self.db.values())\n</code></pre>"},{"location":"code_reference/bibliography/#pybibtex.bibliography.Item","title":"<code>Item</code>","text":"<p>Bibliography item.</p> <p>You can access the fields directly using <code>item['key']</code>.</p> <p>Note</p> <p><code>item_type</code> and <code>cite_key</code> are case technically case insensitive, but the actual <code>cite_key</code> is kept</p> Source code in <code>pybibtex/bibliography.py</code> <pre><code>class Item:\n\"\"\"Bibliography item.\n\n    You can access the fields directly using ``item['key']``.\n\n    !!! note\n        `item_type` and `cite_key` are case technically case insensitive,\n        but the actual `cite_key` is kept\n\n    \"\"\"\n    def __init__(self, cite_key: str, item_type: str = 'article', fields: dict = None):\n\"\"\"Initialize the object\"\"\"\n        self.cite_key = cite_key  #: citation key\n        self.item_type = item_type.lower()  #: item type (article, book, ...)\n        self.fields = fields\n\n    def authors(self, possible_fields: Iterable[str] = ('author', 'Author', 'AUTHOR')) -&gt; List[Author]:\n\"\"\"Get a list of ``Authors``.\n\n        Parameters:\n            possible_fields: looks for the fields in ``possible_fields`` to get the authors, stops when found.\n        \"\"\"\n        for f in possible_fields:\n            if f in self.fields:\n                return AuthorsParser(self.fields[f]).authors()\n\n        return []\n\n    def __repr__(self) -&gt; str:\n        return \"Item('{}', '{}')\".format(self.cite_key, self.item_type)\n\n    def __getitem__(self, item: str) -&gt; str:\n        return self.fields[item]\n\n    def __setitem__(self, key, value):\n        self.fields[key] = value\n\n    def __contains__(self, item: str) -&gt; bool:\n        return item in self.fields\n\n    def __str__(self) -&gt; str:\n\"\"\"Outputs bibtex item\n        \"\"\"\n\n        return '@{}{{{},\\n  {}\\n}}'.format(\n            self.item_type,\n            self.cite_key,\n            ',\\n  '.join('{} = {{{}}}'.format(k, v) for k, v in self.fields.items()))\n</code></pre>"},{"location":"code_reference/bibliography/#pybibtex.bibliography.Item.__init__","title":"<code>__init__(cite_key, item_type='article', fields=None)</code>","text":"<p>Initialize the object</p> Source code in <code>pybibtex/bibliography.py</code> <pre><code>def __init__(self, cite_key: str, item_type: str = 'article', fields: dict = None):\n\"\"\"Initialize the object\"\"\"\n    self.cite_key = cite_key  #: citation key\n    self.item_type = item_type.lower()  #: item type (article, book, ...)\n    self.fields = fields\n</code></pre>"},{"location":"code_reference/bibliography/#pybibtex.bibliography.Item.__str__","title":"<code>__str__()</code>","text":"<p>Outputs bibtex item</p> Source code in <code>pybibtex/bibliography.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Outputs bibtex item\n    \"\"\"\n\n    return '@{}{{{},\\n  {}\\n}}'.format(\n        self.item_type,\n        self.cite_key,\n        ',\\n  '.join('{} = {{{}}}'.format(k, v) for k, v in self.fields.items()))\n</code></pre>"},{"location":"code_reference/bibliography/#pybibtex.bibliography.Item.authors","title":"<code>authors(possible_fields=('author', 'Author', 'AUTHOR'))</code>","text":"<p>Get a list of <code>Authors</code>.</p> <p>Parameters:</p> Name Type Description Default <code>possible_fields</code> <code>Iterable[str]</code> <p>looks for the fields in <code>possible_fields</code> to get the authors, stops when found.</p> <code>('author', 'Author', 'AUTHOR')</code> Source code in <code>pybibtex/bibliography.py</code> <pre><code>def authors(self, possible_fields: Iterable[str] = ('author', 'Author', 'AUTHOR')) -&gt; List[Author]:\n\"\"\"Get a list of ``Authors``.\n\n    Parameters:\n        possible_fields: looks for the fields in ``possible_fields`` to get the authors, stops when found.\n    \"\"\"\n    for f in possible_fields:\n        if f in self.fields:\n            return AuthorsParser(self.fields[f]).authors()\n\n    return []\n</code></pre>"},{"location":"code_reference/parser/","title":"BibTeX Parser","text":"<p>Example of usage:</p> <pre><code>from pybibtex.parser import Parser\n\nbibtex = \"\"\"\n@string(bibtex = \"BiB{\\TeX}\")\n@misc{bibtexing,\n   author = \"Oren Patashnik\",\n   title = bibtex # \"ing\",\n   year = 1988\n}\n\"\"\"\n\nparser = Parser(bibtex)\ndatabase = parser.parse()\n\n# access to item\nassert 'bibtexing' in database\n\n# you can access the string variables after `parse()`\nprint(parser.string_variables['bibtex'])  # prints \"BiB{\\TeX}\"\n</code></pre>"},{"location":"code_reference/parser/#pybibtex.parser.Lexer","title":"<code>Lexer</code>","text":"Source code in <code>pybibtex/parser.py</code> <pre><code>class Lexer:\n    def __init__(self, inp):\n        self.input = inp\n        self.position = -1\n        self.current_char = None\n\n        self.next()\n\n    def next(self):\n\"\"\"Go to next token\n        \"\"\"\n\n        self.position += 1\n\n        if self.position &gt;= len(self.input):\n            self.current_char = '\\0'\n        else:\n            self.current_char = self.input[self.position]\n\n    def tokenize(self) -&gt; Iterator[Token]:\n        while self.current_char != '\\0':\n            if self.current_char in SYMBOL_TR:\n                yield Token(SYMBOL_TR[self.current_char], self.current_char, self.position)\n            else:\n                yield Token(TokenType.CHAR, self.current_char, self.position)\n            self.next()\n\n        yield Token(TokenType.EOS, '\\0', self.position)\n</code></pre>"},{"location":"code_reference/parser/#pybibtex.parser.Lexer.next","title":"<code>next()</code>","text":"<p>Go to next token</p> Source code in <code>pybibtex/parser.py</code> <pre><code>def next(self):\n\"\"\"Go to next token\n    \"\"\"\n\n    self.position += 1\n\n    if self.position &gt;= len(self.input):\n        self.current_char = '\\0'\n    else:\n        self.current_char = self.input[self.position]\n</code></pre>"},{"location":"code_reference/parser/#pybibtex.parser.Parser","title":"<code>Parser</code>","text":"<p>Parser for the bibliography in BiBTeX format</p> Source code in <code>pybibtex/parser.py</code> <pre><code>class Parser:\n\"\"\"Parser for the bibliography in BiBTeX format\n    \"\"\"\n\n    def __init__(self, inp: str):\n\"\"\"Initialize the object\n\n        Parameters:\n            inp: string containing the BiBTeX database\n        \"\"\"\n\n        self.lexer = Lexer(inp)\n        self.tokenizer = self.lexer.tokenize()\n        self.current_token: Token = None\n\n        # month are defined by default\n        self.string_variables = {\n            'jan': 'january',\n            'feb': 'february',\n            'mar': 'march',\n            'apr': 'april',\n            'may': 'may',\n            'jun': 'june',\n            'jul': 'july',\n            'aug': 'august',\n            'sep': 'september',\n            'oct': 'october',\n            'nov': 'november',\n            'dec': 'december'\n        }\n\n        self.next()\n\n    def _next(self):\n\"\"\"Get next token\"\"\"\n\n        try:\n            self.current_token = next(self.tokenizer)\n        except StopIteration:\n            self.current_token = Token(TokenType.EOS, '\\0')\n\n    def next(self):\n\"\"\"Get next token\"\"\"\n\n        self._next()\n\n    def eat(self, typ: TokenType):\n        if self.current_token.type == typ:\n            self.next()\n        else:\n            raise ParserSyntaxError('expected {}, got {}'.format(typ, self.current_token))\n\n    def skip_empty(self):\n\"\"\"Skip spaces, newlines and comments\n        \"\"\"\n\n        while self.current_token.type in [TokenType.SPACE, TokenType.NL]:\n            self.next()\n\n    def skip_any_but_item(self):\n\"\"\"Skip anything until the next @, since it is considered to be a comment\n        \"\"\"\n\n        while self.current_token.type not in [TokenType.AT, TokenType.EOS]:\n            self.next()\n\n    def parse(self) -&gt; Database:\n        return self.database()\n\n    def literal(self) -&gt; str:\n\"\"\"Get a literal, as\n\n        ```text\n        literal := [a-aA-Z_] [a-zA-Z0-9_]*\n        ```\n\n        !!! note\n            It cannot start by an integer, for obvious reasons.\n        \"\"\"\n\n        if self.current_token.type != TokenType.CHAR or not IS_LITERAL_BEG.match(self.current_token.value):\n            raise ParserSyntaxError('expected literal, got {}'.format(self.current_token))\n\n        literal = self.current_token.value\n        self.next()\n\n        while self.current_token.type == TokenType.CHAR and IS_LITERAL.match(self.current_token.value):\n            literal += self.current_token.value\n            self.next()\n\n        return literal\n\n    def key(self) -&gt; str:\n\"\"\"Get a key,\n\n\n        ```text\n        key := [a-zA-Z0-9_\\\\-:]*\n        ```\n\n        !!! note\n            That means that a key can start by an integer or ``:`` (that should not be a problem)\n        \"\"\"\n\n        if self.current_token.type != TokenType.CHAR or not IS_KEY.match(self.current_token.value):\n            raise ParserSyntaxError('expected literal, got {}'.format(self.current_token))\n\n        citekey = ''\n\n        while self.current_token.type == TokenType.CHAR and IS_KEY.match(self.current_token.value):\n            citekey += self.current_token.value\n            self.next()\n\n        return citekey\n\n    def database(self) -&gt; Database:\n\"\"\"\n        The BibTeX format is more or less defined as\n\n        ```text\n        bibtex := (item | string_var | comment)*;\n        ```\n\n        with\n\n        ```text\n        string_var := AT 'string' (LCBRACE inside_string_var RCBRACE | LPAR inside_string_var RPAR) ;\n        item := AT literal (LCBRACE inside_item RCBRACE | LPAR inside_item RPAR) ;\n        comment := (AT 'comment' CHAR* NL | CHAR*)\n        ```\n\n        (it is missing the `@preamble` instruction).\n        \"\"\"\n\n        db = {}\n        self.skip_any_but_item()  # go to the next @\n\n        while self.current_token.type != TokenType.EOS:\n            self.eat(TokenType.AT)\n\n            # get type\n            item_type = self.literal()\n            self.skip_empty()\n\n            if item_type.lower() == 'comment':\n                self.comment()\n            else:\n                # get opening\n                if self.current_token.type not in OPENINGS:\n                    raise ParserSyntaxError('expected OPENINGS, got {}'.format(self.current_token))\n\n                opening = self.current_token.type\n                closing = {\n                    TokenType.LPAR: TokenType.RPAR,\n                    TokenType.LCBRACE: TokenType.RCBRACE\n                }[opening]\n\n                self.next()\n                self.skip_empty()\n\n                # go inside\n                if item_type.lower() == 'string':\n                    self.inside_string_var()\n                else:\n                    item = self.inside_item(item_type)\n                    db[item.cite_key.lower()] = item\n\n                self.skip_empty()\n                self.eat(closing)\n\n            self.skip_any_but_item()\n\n        self.eat(TokenType.EOS)\n        return Database(db)\n\n    def comment(self):\n\"\"\"Skip whatever remains of the line\n        \"\"\"\n\n        while self.current_token.type not in [TokenType.NL, TokenType.EOS]:\n            self.next()\n\n    def inside_string_var(self):\n\"\"\"Defines a string variable:\n\n        ```text\n        inside_string_var := key EQUAL value ;\n        ```\n\n        !!! note\n            `key` is maybe a bit broadly defined (is `:` valid?)\n        \"\"\"\n\n        # get placeholder\n        placeholder = self.literal()\n\n        # eat EQUAL\n        self.skip_empty()\n        self.eat(TokenType.EQUAL)\n        self.skip_empty()\n\n        # get value and define\n        value = self.value()\n        self.string_variables[placeholder] = value\n\n    def inside_item(self, item_type: str) -&gt; Item:\n\"\"\"Get an item:\n\n        ```text\n        inside_item := key COMMA (field (COMMA field)*)? COMMA?\n        ```\n\n        \"\"\"\n\n        # get key\n        item_citekey = self.key()\n\n        # eat COMMA\n        self.skip_empty()\n        self.eat(TokenType.COMMA)\n        self.skip_empty()\n\n        # get fields\n        fields = {}\n        while True:\n\n            if self.current_token.type == TokenType.COMMA:  # empty value, skip\n                self.next()\n                continue\n\n            elif self.current_token.type in [TokenType.RCBRACE, TokenType.RPAR]:  # that's the end of it!\n                break\n\n            try:\n                k, v = self.field()\n            except ParserSyntaxError as e:\n                raise ParserSyntaxError('while parsing {}, {}'.format(item_citekey, e))\n\n            fields[k] = v\n\n            self.skip_empty()\n            if self.current_token.type != TokenType.COMMA:\n                break\n            else:\n                self.next()\n                self.skip_empty()\n\n        return Item(cite_key=item_citekey, item_type=item_type, fields=fields)\n\n    def field(self) -&gt; Tuple[str, str]:\n\"\"\"\n        Get a field:\n\n        ```text\n        field := key EQUAL value ;\n        ```\n\n        \"\"\"\n\n        # get key\n        key = self.key()\n\n        # eat EQUAL\n        self.skip_empty()\n        self.eat(TokenType.EQUAL)\n        self.skip_empty()\n\n        # get value and return\n        return key, self.value()\n\n    def value(self) -&gt; str:\n\"\"\"A value is a string, but different stuffs can be concatenated.\n\n        ```text\n        value := string_part (POUND string_part)* ;\n        ```\n\n        !!! note\n            It means that integer can be concatenated, deal with it.\n        \"\"\"\n        value = self.string_part()\n\n        # concatenate?\n        self.skip_empty()\n\n        while self.current_token.type == TokenType.POUND:\n            # eat POUND\n            self.next()\n            self.skip_empty()\n\n            # get next value\n            value += self.string_part()\n            self.skip_empty()\n\n        # ok, done\n        return value\n\n    def string_part(self) -&gt; str:\n\"\"\"Get an actual string.\n\n        Note that for a quote to be escaped, it must be inside braces.\n        Which means that braces **must** match, even in quote.\n\n        ```text\n        INTEGER := [0-9]\n\n        sl := CHAR*\n           | QUOTE\n           | LBRACE sl* RBRACE\n           ;\n\n        string_part := literal\n                    | INTEGER INTEGER*\n                    | LBRACE sl* RBRACE\n                    | QQUOTE (CHAR* | LCBRACE sl* RCBRACE)* QUOTE\n                    ;\n        ```\n        \"\"\"\n\n        if self.current_token.type == TokenType.CHAR:\n            if self.current_token.value.isnumeric():  # its a pure integer\n                value = ''\n                while self.current_token.type == TokenType.CHAR and self.current_token.value.isnumeric():\n                    value += self.current_token.value\n                    self.next()\n            else:  # ... it is a literal, then\n                lit = self.literal()\n                try:\n                    value = self.string_variables[lit]\n                except KeyError:\n                    raise ParserSyntaxError('{} is not defined'.format(lit))\n\n        elif self.current_token.type in [TokenType.LCBRACE, TokenType.QUOTE]:\n            opening_char = self.current_token.type\n            self.next()\n\n            value = ''\n            brace_level = 1 if opening_char == TokenType.LCBRACE else 0\n            while True:\n                if self.current_token.type == TokenType.LCBRACE:\n                    brace_level += 1\n                elif self.current_token.type == TokenType.RCBRACE:\n                    brace_level -= 1\n                    if opening_char == TokenType.LCBRACE and brace_level == 0:\n                        self.next()\n                        break\n                elif self.current_token.type == TokenType.QUOTE:\n                    if opening_char == TokenType.QUOTE and brace_level == 0:\n                        self.next()\n                        break\n                elif self.current_token.type == TokenType.EOS:\n                    raise ParserSyntaxError('got {} while parsing string'.format(self.current_token))\n\n                value += self.current_token.value\n                self.next()\n        else:\n            raise ParserSyntaxError('expected string, got {}'.format(self.current_token))\n\n        return value\n</code></pre>"},{"location":"code_reference/parser/#pybibtex.parser.Parser.__init__","title":"<code>__init__(inp)</code>","text":"<p>Initialize the object</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>string containing the BiBTeX database</p> required Source code in <code>pybibtex/parser.py</code> <pre><code>def __init__(self, inp: str):\n\"\"\"Initialize the object\n\n    Parameters:\n        inp: string containing the BiBTeX database\n    \"\"\"\n\n    self.lexer = Lexer(inp)\n    self.tokenizer = self.lexer.tokenize()\n    self.current_token: Token = None\n\n    # month are defined by default\n    self.string_variables = {\n        'jan': 'january',\n        'feb': 'february',\n        'mar': 'march',\n        'apr': 'april',\n        'may': 'may',\n        'jun': 'june',\n        'jul': 'july',\n        'aug': 'august',\n        'sep': 'september',\n        'oct': 'october',\n        'nov': 'november',\n        'dec': 'december'\n    }\n\n    self.next()\n</code></pre>"},{"location":"code_reference/parser/#pybibtex.parser.Parser.comment","title":"<code>comment()</code>","text":"<p>Skip whatever remains of the line</p> Source code in <code>pybibtex/parser.py</code> <pre><code>def comment(self):\n\"\"\"Skip whatever remains of the line\n    \"\"\"\n\n    while self.current_token.type not in [TokenType.NL, TokenType.EOS]:\n        self.next()\n</code></pre>"},{"location":"code_reference/parser/#pybibtex.parser.Parser.database","title":"<code>database()</code>","text":"<p>The BibTeX format is more or less defined as</p> <pre><code>bibtex := (item | string_var | comment)*;\n</code></pre> <p>with</p> <pre><code>string_var := AT 'string' (LCBRACE inside_string_var RCBRACE | LPAR inside_string_var RPAR) ;\nitem := AT literal (LCBRACE inside_item RCBRACE | LPAR inside_item RPAR) ;\ncomment := (AT 'comment' CHAR* NL | CHAR*)\n</code></pre> <p>(it is missing the <code>@preamble</code> instruction).</p> Source code in <code>pybibtex/parser.py</code> <pre><code>def database(self) -&gt; Database:\n\"\"\"\n    The BibTeX format is more or less defined as\n\n    ```text\n    bibtex := (item | string_var | comment)*;\n    ```\n\n    with\n\n    ```text\n    string_var := AT 'string' (LCBRACE inside_string_var RCBRACE | LPAR inside_string_var RPAR) ;\n    item := AT literal (LCBRACE inside_item RCBRACE | LPAR inside_item RPAR) ;\n    comment := (AT 'comment' CHAR* NL | CHAR*)\n    ```\n\n    (it is missing the `@preamble` instruction).\n    \"\"\"\n\n    db = {}\n    self.skip_any_but_item()  # go to the next @\n\n    while self.current_token.type != TokenType.EOS:\n        self.eat(TokenType.AT)\n\n        # get type\n        item_type = self.literal()\n        self.skip_empty()\n\n        if item_type.lower() == 'comment':\n            self.comment()\n        else:\n            # get opening\n            if self.current_token.type not in OPENINGS:\n                raise ParserSyntaxError('expected OPENINGS, got {}'.format(self.current_token))\n\n            opening = self.current_token.type\n            closing = {\n                TokenType.LPAR: TokenType.RPAR,\n                TokenType.LCBRACE: TokenType.RCBRACE\n            }[opening]\n\n            self.next()\n            self.skip_empty()\n\n            # go inside\n            if item_type.lower() == 'string':\n                self.inside_string_var()\n            else:\n                item = self.inside_item(item_type)\n                db[item.cite_key.lower()] = item\n\n            self.skip_empty()\n            self.eat(closing)\n\n        self.skip_any_but_item()\n\n    self.eat(TokenType.EOS)\n    return Database(db)\n</code></pre>"},{"location":"code_reference/parser/#pybibtex.parser.Parser.field","title":"<code>field()</code>","text":"<p>Get a field:</p> <pre><code>field := key EQUAL value ;\n</code></pre> Source code in <code>pybibtex/parser.py</code> <pre><code>def field(self) -&gt; Tuple[str, str]:\n\"\"\"\n    Get a field:\n\n    ```text\n    field := key EQUAL value ;\n    ```\n\n    \"\"\"\n\n    # get key\n    key = self.key()\n\n    # eat EQUAL\n    self.skip_empty()\n    self.eat(TokenType.EQUAL)\n    self.skip_empty()\n\n    # get value and return\n    return key, self.value()\n</code></pre>"},{"location":"code_reference/parser/#pybibtex.parser.Parser.inside_item","title":"<code>inside_item(item_type)</code>","text":"<p>Get an item:</p> <pre><code>inside_item := key COMMA (field (COMMA field)*)? COMMA?\n</code></pre> Source code in <code>pybibtex/parser.py</code> <pre><code>def inside_item(self, item_type: str) -&gt; Item:\n\"\"\"Get an item:\n\n    ```text\n    inside_item := key COMMA (field (COMMA field)*)? COMMA?\n    ```\n\n    \"\"\"\n\n    # get key\n    item_citekey = self.key()\n\n    # eat COMMA\n    self.skip_empty()\n    self.eat(TokenType.COMMA)\n    self.skip_empty()\n\n    # get fields\n    fields = {}\n    while True:\n\n        if self.current_token.type == TokenType.COMMA:  # empty value, skip\n            self.next()\n            continue\n\n        elif self.current_token.type in [TokenType.RCBRACE, TokenType.RPAR]:  # that's the end of it!\n            break\n\n        try:\n            k, v = self.field()\n        except ParserSyntaxError as e:\n            raise ParserSyntaxError('while parsing {}, {}'.format(item_citekey, e))\n\n        fields[k] = v\n\n        self.skip_empty()\n        if self.current_token.type != TokenType.COMMA:\n            break\n        else:\n            self.next()\n            self.skip_empty()\n\n    return Item(cite_key=item_citekey, item_type=item_type, fields=fields)\n</code></pre>"},{"location":"code_reference/parser/#pybibtex.parser.Parser.inside_string_var","title":"<code>inside_string_var()</code>","text":"<p>Defines a string variable:</p> <pre><code>inside_string_var := key EQUAL value ;\n</code></pre> <p>Note</p> <p><code>key</code> is maybe a bit broadly defined (is <code>:</code> valid?)</p> Source code in <code>pybibtex/parser.py</code> <pre><code>def inside_string_var(self):\n\"\"\"Defines a string variable:\n\n    ```text\n    inside_string_var := key EQUAL value ;\n    ```\n\n    !!! note\n        `key` is maybe a bit broadly defined (is `:` valid?)\n    \"\"\"\n\n    # get placeholder\n    placeholder = self.literal()\n\n    # eat EQUAL\n    self.skip_empty()\n    self.eat(TokenType.EQUAL)\n    self.skip_empty()\n\n    # get value and define\n    value = self.value()\n    self.string_variables[placeholder] = value\n</code></pre>"},{"location":"code_reference/parser/#pybibtex.parser.Parser.key","title":"<code>key()</code>","text":"<p>Get a key,</p> <pre><code>key := [a-zA-Z0-9_\\-:]*\n</code></pre> <p>Note</p> <p>That means that a key can start by an integer or <code>:</code> (that should not be a problem)</p> Source code in <code>pybibtex/parser.py</code> <pre><code>def key(self) -&gt; str:\n\"\"\"Get a key,\n\n\n    ```text\n    key := [a-zA-Z0-9_\\\\-:]*\n    ```\n\n    !!! note\n        That means that a key can start by an integer or ``:`` (that should not be a problem)\n    \"\"\"\n\n    if self.current_token.type != TokenType.CHAR or not IS_KEY.match(self.current_token.value):\n        raise ParserSyntaxError('expected literal, got {}'.format(self.current_token))\n\n    citekey = ''\n\n    while self.current_token.type == TokenType.CHAR and IS_KEY.match(self.current_token.value):\n        citekey += self.current_token.value\n        self.next()\n\n    return citekey\n</code></pre>"},{"location":"code_reference/parser/#pybibtex.parser.Parser.literal","title":"<code>literal()</code>","text":"<p>Get a literal, as</p> <pre><code>literal := [a-aA-Z_] [a-zA-Z0-9_]*\n</code></pre> <p>Note</p> <p>It cannot start by an integer, for obvious reasons.</p> Source code in <code>pybibtex/parser.py</code> <pre><code>def literal(self) -&gt; str:\n\"\"\"Get a literal, as\n\n    ```text\n    literal := [a-aA-Z_] [a-zA-Z0-9_]*\n    ```\n\n    !!! note\n        It cannot start by an integer, for obvious reasons.\n    \"\"\"\n\n    if self.current_token.type != TokenType.CHAR or not IS_LITERAL_BEG.match(self.current_token.value):\n        raise ParserSyntaxError('expected literal, got {}'.format(self.current_token))\n\n    literal = self.current_token.value\n    self.next()\n\n    while self.current_token.type == TokenType.CHAR and IS_LITERAL.match(self.current_token.value):\n        literal += self.current_token.value\n        self.next()\n\n    return literal\n</code></pre>"},{"location":"code_reference/parser/#pybibtex.parser.Parser.next","title":"<code>next()</code>","text":"<p>Get next token</p> Source code in <code>pybibtex/parser.py</code> <pre><code>def next(self):\n\"\"\"Get next token\"\"\"\n\n    self._next()\n</code></pre>"},{"location":"code_reference/parser/#pybibtex.parser.Parser.skip_any_but_item","title":"<code>skip_any_but_item()</code>","text":"<p>Skip anything until the next @, since it is considered to be a comment</p> Source code in <code>pybibtex/parser.py</code> <pre><code>def skip_any_but_item(self):\n\"\"\"Skip anything until the next @, since it is considered to be a comment\n    \"\"\"\n\n    while self.current_token.type not in [TokenType.AT, TokenType.EOS]:\n        self.next()\n</code></pre>"},{"location":"code_reference/parser/#pybibtex.parser.Parser.skip_empty","title":"<code>skip_empty()</code>","text":"<p>Skip spaces, newlines and comments</p> Source code in <code>pybibtex/parser.py</code> <pre><code>def skip_empty(self):\n\"\"\"Skip spaces, newlines and comments\n    \"\"\"\n\n    while self.current_token.type in [TokenType.SPACE, TokenType.NL]:\n        self.next()\n</code></pre>"},{"location":"code_reference/parser/#pybibtex.parser.Parser.string_part","title":"<code>string_part()</code>","text":"<p>Get an actual string.</p> <p>Note that for a quote to be escaped, it must be inside braces. Which means that braces must match, even in quote.</p> <pre><code>INTEGER := [0-9]\n\nsl := CHAR*\n   | QUOTE\n   | LBRACE sl* RBRACE\n   ;\n\nstring_part := literal\n            | INTEGER INTEGER*\n            | LBRACE sl* RBRACE\n            | QQUOTE (CHAR* | LCBRACE sl* RCBRACE)* QUOTE\n            ;\n</code></pre> Source code in <code>pybibtex/parser.py</code> <pre><code>def string_part(self) -&gt; str:\n\"\"\"Get an actual string.\n\n    Note that for a quote to be escaped, it must be inside braces.\n    Which means that braces **must** match, even in quote.\n\n    ```text\n    INTEGER := [0-9]\n\n    sl := CHAR*\n       | QUOTE\n       | LBRACE sl* RBRACE\n       ;\n\n    string_part := literal\n                | INTEGER INTEGER*\n                | LBRACE sl* RBRACE\n                | QQUOTE (CHAR* | LCBRACE sl* RCBRACE)* QUOTE\n                ;\n    ```\n    \"\"\"\n\n    if self.current_token.type == TokenType.CHAR:\n        if self.current_token.value.isnumeric():  # its a pure integer\n            value = ''\n            while self.current_token.type == TokenType.CHAR and self.current_token.value.isnumeric():\n                value += self.current_token.value\n                self.next()\n        else:  # ... it is a literal, then\n            lit = self.literal()\n            try:\n                value = self.string_variables[lit]\n            except KeyError:\n                raise ParserSyntaxError('{} is not defined'.format(lit))\n\n    elif self.current_token.type in [TokenType.LCBRACE, TokenType.QUOTE]:\n        opening_char = self.current_token.type\n        self.next()\n\n        value = ''\n        brace_level = 1 if opening_char == TokenType.LCBRACE else 0\n        while True:\n            if self.current_token.type == TokenType.LCBRACE:\n                brace_level += 1\n            elif self.current_token.type == TokenType.RCBRACE:\n                brace_level -= 1\n                if opening_char == TokenType.LCBRACE and brace_level == 0:\n                    self.next()\n                    break\n            elif self.current_token.type == TokenType.QUOTE:\n                if opening_char == TokenType.QUOTE and brace_level == 0:\n                    self.next()\n                    break\n            elif self.current_token.type == TokenType.EOS:\n                raise ParserSyntaxError('got {} while parsing string'.format(self.current_token))\n\n            value += self.current_token.value\n            self.next()\n    else:\n        raise ParserSyntaxError('expected string, got {}'.format(self.current_token))\n\n    return value\n</code></pre>"},{"location":"code_reference/parser/#pybibtex.parser.Parser.value","title":"<code>value()</code>","text":"<p>A value is a string, but different stuffs can be concatenated.</p> <pre><code>value := string_part (POUND string_part)* ;\n</code></pre> <p>Note</p> <p>It means that integer can be concatenated, deal with it.</p> Source code in <code>pybibtex/parser.py</code> <pre><code>def value(self) -&gt; str:\n\"\"\"A value is a string, but different stuffs can be concatenated.\n\n    ```text\n    value := string_part (POUND string_part)* ;\n    ```\n\n    !!! note\n        It means that integer can be concatenated, deal with it.\n    \"\"\"\n    value = self.string_part()\n\n    # concatenate?\n    self.skip_empty()\n\n    while self.current_token.type == TokenType.POUND:\n        # eat POUND\n        self.next()\n        self.skip_empty()\n\n        # get next value\n        value += self.string_part()\n        self.skip_empty()\n\n    # ok, done\n    return value\n</code></pre>"},{"location":"code_reference/utf8/","title":"UTF-8 handling","text":"<p>Example of usage:</p> <pre><code>from pybibtex.latexutf8 import utf8decode, utf8encode\n\n# prints \"\\'Emile de la Tourbi\\`ere\"\nprint(utf8decode('\u00c9mile de la Tourbi\u00e8re')) \n\n# prints \"\u00c9mile de la Tourbi\u00e8re\"\nprint(utf8encode(\"\\\\'Emile de la Tourbi\\\\`ere\"))\n</code></pre>"},{"location":"code_reference/utf8/#pybibtex.latexutf8.UTF8EncodeException","title":"<code>UTF8EncodeException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Exception raised when there is an error in the input string</p> Source code in <code>pybibtex/latexutf8.py</code> <pre><code>class UTF8EncodeException(Exception):\n\"\"\"Exception raised when there is an error in the input string\n    \"\"\"\n    pass\n</code></pre>"},{"location":"code_reference/utf8/#pybibtex.latexutf8.utf8encode","title":"<code>utf8encode(inp)</code>","text":"<p>Replace LaTeX characters by their UTF-8 equivalent</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>string containing LaTeX macros</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string with the UTF-8 equivalent of the macros</p> Source code in <code>pybibtex/latexutf8.py</code> <pre><code>def utf8encode(inp: str) -&gt; str:\n\"\"\"Replace LaTeX characters by their UTF-8 equivalent\n\n    Parameters:\n        inp: string containing LaTeX macros\n\n    Returns:\n        A string with the UTF-8 equivalent of the macros\n    \"\"\"\n\n    return LtxUTF8Parser(inp, REVERSE_TRANSLATION_TABLE).transform()\n</code></pre>"},{"location":"code_reference/utf8/#pybibtex.latexutf8.utf8decode","title":"<code>utf8decode(inp)</code>","text":"<p>Replace dec:lared UTF-8 character by their LaTeX equivalent</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>string containing special UTF-8 characters</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string with the LaTeX equivalent of UTF-8 characters</p> Source code in <code>pybibtex/latexutf8.py</code> <pre><code>def utf8decode(inp: str) -&gt; str:\n\"\"\"Replace dec:lared UTF-8 character by their LaTeX equivalent\n\n    Parameters:\n        inp: string containing special UTF-8 characters\n\n    Returns:\n        A string with the LaTeX equivalent of UTF-8 characters\n    \"\"\"\n    return inp.translate(TRANSLATION_TABLE)\n</code></pre>"}]}