{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pybibtex : a (very) simple BibTeX parser \u00a4 Provides a Python API to parse BibTeX files. Not to be confused with the (actual) pybibtex : while this implementation is a more clever approach (this is actual syntax parsing, not REGEX). The BiBTeX syntax is introduced, simply, there . More details are found in btxdoc (and some of its quirks are examplified here ). This implementation handles the different syntax for the items (braces or parentheses), the comments, and the concatenation (with the @string definitions). It does not handle @preamble . Install & use \u00a4 pip3 install --upgrade git+https://github.com/pierre-24/pybibtex.git@v0.2.0 No dependencies are required (except python >= 3.6). See the documentation there demonstrating the (quite simple) API. Contribute \u00a4 Contributions, either with issues or pull requests are welcomed. See the Contributing section of the documentation for more details.","title":"Home"},{"location":"#pybibtex-a-very-simple-bibtex-parser","text":"Provides a Python API to parse BibTeX files. Not to be confused with the (actual) pybibtex : while this implementation is a more clever approach (this is actual syntax parsing, not REGEX). The BiBTeX syntax is introduced, simply, there . More details are found in btxdoc (and some of its quirks are examplified here ). This implementation handles the different syntax for the items (braces or parentheses), the comments, and the concatenation (with the @string definitions). It does not handle @preamble .","title":"pybibtex: a (very) simple BibTeX parser"},{"location":"#install-use","text":"pip3 install --upgrade git+https://github.com/pierre-24/pybibtex.git@v0.2.0 No dependencies are required (except python >= 3.6). See the documentation there demonstrating the (quite simple) API.","title":"Install &amp; use"},{"location":"#contribute","text":"Contributions, either with issues or pull requests are welcomed. See the Contributing section of the documentation for more details.","title":"Contribute"},{"location":"contributing/","text":"If you want to contribute, this is the usual deal: Start by forking , then clone your fork git clone git@github.com:<YOUR_USERNAME>/pybibtex.git cd pybibtex Then setup... And you are good to go :) python -m venv venv # a virtualenv is always a good idea source venv/bin/activate make init # install what's needed for dev You can also build the documentation with make doc And then visit site/index.html . Don't forget to work on a separate branch, and to run the linting and tests: make lint # flake8 make test # unit tests Design rules \u00a4 The code is written in Python 3, and follows the (in)famous PEP-8 . You can check it by running make lint , which launch the flake utility. Codes and comments are written in english. The code is documented using docstrings and mkdocs . The docstrings must contain the basic description of the function, as well as a description of the parameters. The code is tested. You can launch the test series by using make test . Every functionality should be provided with at least one unit test. The package is documented. You can generate this documentation by using make doc . Non-basic stuffs should be explained in this documentation. Don't forget to cite some articles or website if needed. Workflow \u00a4 Adapted from the (in)famous Git flow . This project is not large enough to have a dev branch, the tags should be sufficient. Development is made in the master branch, which contains the production version. Functionality are added through merge request (MR) in the master branch. Do not work in master directly, but create a new branch ( git checkout -b my_branch origin/master ). Theses merge requests should be unitary, and include unit test(s) and documentation if needed. The test suite must succeed for the merge request to be accepted. At some (random) points, a new version is created, with a tag of the form vX.Y.Z .","title":"Contributing"},{"location":"contributing/#design-rules","text":"The code is written in Python 3, and follows the (in)famous PEP-8 . You can check it by running make lint , which launch the flake utility. Codes and comments are written in english. The code is documented using docstrings and mkdocs . The docstrings must contain the basic description of the function, as well as a description of the parameters. The code is tested. You can launch the test series by using make test . Every functionality should be provided with at least one unit test. The package is documented. You can generate this documentation by using make doc . Non-basic stuffs should be explained in this documentation. Don't forget to cite some articles or website if needed.","title":"Design rules"},{"location":"contributing/#workflow","text":"Adapted from the (in)famous Git flow . This project is not large enough to have a dev branch, the tags should be sufficient. Development is made in the master branch, which contains the production version. Functionality are added through merge request (MR) in the master branch. Do not work in master directly, but create a new branch ( git checkout -b my_branch origin/master ). Theses merge requests should be unitary, and include unit test(s) and documentation if needed. The test suite must succeed for the merge request to be accepted. At some (random) points, a new version is created, with a tag of the form vX.Y.Z .","title":"Workflow"},{"location":"usage/","text":"Here are 3 example of the usage you can have of pybibtex . Import and use bibliography \u00a4 Say you want to import this BibTeX file, stored in example.bib . @string ( bibtex = \"BiB{\\TeX}\" ) @comment that's a comment @misc { bibtexing , author = \"Oren Patashnik\" , title = bibtex # \"ing\" , year = 1988 , url = {https://www.ctan.org/tex-archive/biblio/bibtex/contrib/doc/} } Yes, between items, you can write whatever you want! You can import this bibliography using from pybibtex.parser import Parser with open ( 'test.bib' ) as bibfile : database = Parser ( bibfile . read ()) . parse () You can check and access the items via their citation key: assert 'bibtexing' in database item = database [ 'bibtexing' ] Note that per BibTeX specification, the citation key is case insensitive, so that the following code results in the same item: item = database [ 'BiBTEXing' ] A bibliography item contains the different fields, which are directly addressable: assert 'title' in item print ( item [ 'title' ]) print ( item [ 'year' ]) This results in Bib\\TeXing 1988 The first line demonstrate the concatenation at line 7 of test.bib. You can access the citation key with item.cite_key and the item type with item.item_type . Get authors \u00a4 pybibtex provides a convenient API to extract the authors. One way to use it is from pybibtex.authors import AuthorsParser authors = AuthorsParser ( 'Pierre Beaujean and de la Fontaine, Jean' ) . authors () But you can also access the author of a bibliography item with this specific function: authors = item . authors () Both methods return a list of Author . You can then access its last name, with author.last (always not empty), its first name, with author.first (may be empty), its \"von\" part, with author.von (may be empty), its \"jr\" part, with author.jr (may be empty). Convert accentuated strings \u00a4 LaTeX is notoriously (in)famous for its way to handle UTF-8 characters. You can convert a string to this format using from pybibtex.latexutf8 import utf8decode print ( utf8decode ( '\u00c9mile de la Tourbi\u00e8re' )) which outputs: \\'Emile de la Tourbi\\`ere The converse is obtained with: from pybibtex.latexutf8 import utf8encode print ( utf8encode ( \" \\\\ 'Emile de la Tourbi \\\\ `ere\" ))","title":"Usage"},{"location":"usage/#import-and-use-bibliography","text":"Say you want to import this BibTeX file, stored in example.bib . @string ( bibtex = \"BiB{\\TeX}\" ) @comment that's a comment @misc { bibtexing , author = \"Oren Patashnik\" , title = bibtex # \"ing\" , year = 1988 , url = {https://www.ctan.org/tex-archive/biblio/bibtex/contrib/doc/} } Yes, between items, you can write whatever you want! You can import this bibliography using from pybibtex.parser import Parser with open ( 'test.bib' ) as bibfile : database = Parser ( bibfile . read ()) . parse () You can check and access the items via their citation key: assert 'bibtexing' in database item = database [ 'bibtexing' ] Note that per BibTeX specification, the citation key is case insensitive, so that the following code results in the same item: item = database [ 'BiBTEXing' ] A bibliography item contains the different fields, which are directly addressable: assert 'title' in item print ( item [ 'title' ]) print ( item [ 'year' ]) This results in Bib\\TeXing 1988 The first line demonstrate the concatenation at line 7 of test.bib. You can access the citation key with item.cite_key and the item type with item.item_type .","title":"Import and use bibliography"},{"location":"usage/#get-authors","text":"pybibtex provides a convenient API to extract the authors. One way to use it is from pybibtex.authors import AuthorsParser authors = AuthorsParser ( 'Pierre Beaujean and de la Fontaine, Jean' ) . authors () But you can also access the author of a bibliography item with this specific function: authors = item . authors () Both methods return a list of Author . You can then access its last name, with author.last (always not empty), its first name, with author.first (may be empty), its \"von\" part, with author.von (may be empty), its \"jr\" part, with author.jr (may be empty).","title":"Get authors"},{"location":"usage/#convert-accentuated-strings","text":"LaTeX is notoriously (in)famous for its way to handle UTF-8 characters. You can convert a string to this format using from pybibtex.latexutf8 import utf8decode print ( utf8decode ( '\u00c9mile de la Tourbi\u00e8re' )) which outputs: \\'Emile de la Tourbi\\`ere The converse is obtained with: from pybibtex.latexutf8 import utf8encode print ( utf8encode ( \" \\\\ 'Emile de la Tourbi \\\\ `ere\" ))","title":"Convert accentuated strings"},{"location":"code_reference/authors/","text":"Example of usage: from pybibtex.authors import AuthorsParser authors = AuthorsParser ( 'Pierre Beaujean and de la Fontaine, Jean' ) . authors () assert len ( authors ) == 2 print ( authors [ 0 ] . last ) # prints \"Beaujean\" print ( authors [ 1 ] . first , authors [ 1 ] . von , authors [ 1 ] . last ) # prints \"Jean de la Fontaine\" Author \u00a4 Represent an author You can access: its last name, with author.last (always not empty), its first name, with author.first (may be empty), its \"von\" part, with author.von (may be empty), its \"jr\" part, with author.jr (may be empty). __init__ ( self , first , last , von = '' , jr = '' ) special \u00a4 Initialize the object Source code in pybibtex/authors.py def __init__ ( self , first : str , last : str , von : str = '' , jr : str = '' ): \"\"\"Initialize the object \"\"\" if not last : raise Exception ( 'last must not be empty' ) self . first = first #: author first name (may be empty) self . last = last #: author last name (never empty) self . von = von #: author \"von\" part (may be empty) self . jr = jr #: author \"jr\" part (may be empty) __str__ ( self ) special \u00a4 Return the author in the \"comma\" form (since it is the only one which handle \"jr\") Source code in pybibtex/authors.py def __str__ ( self ): \"\"\"Return the author in the \"comma\" form (since it is the only one which handle \"jr\") \"\"\" return ' {}{} , {}{} ' . format ( '' if not self . von else self . von + ' ' , self . last , '' if not self . jr else ' {} , ' . format ( self . jr ), self . first ) AuthorParserSyntaxError \u00a4 Exception raised when the parser issued an error AuthorsParser \u00a4 Parser to extract the authors __init__ ( self , inp ) special \u00a4 Initialize the object Parameters: Name Type Description Default inp str input string required Source code in pybibtex/authors.py def __init__ ( self , inp : str ): \"\"\"Initialize the object Parameters: inp: input string \"\"\" self . input = inp self . current_token : AuthorToken = None self . tokenizer = self . tokenize () self . next () authors ( self ) \u00a4 Get the list of Author Source code in pybibtex/authors.py def authors ( self ) -> List [ Author ]: \"\"\"Get the list of `Author` \"\"\" return [ s . transform () for s in self . sequences ()] next ( self ) \u00a4 Go to next token Source code in pybibtex/authors.py def next ( self ): \"\"\"Go to next token \"\"\" try : self . current_token = next ( self . tokenizer ) except StopIteration : self . current_token = AuthorToken ( AuthorTokenType . EOS , ' \\0 ' ) sequences ( self ) \u00a4 Get a list of word sequences (either pure or comma separated) separated by \"and\" spaces := SPACE SPACE* ; words := word (spaces word)* comma_sep_seq := words spaces? COMMA spaces? words (spaces? COMMA spaces? words)* ; pure_seq := words sequence := pure_seq | comma_sep_seq ; sequences := sequence (\"and\" sequence)* ; Source code in pybibtex/authors.py def sequences ( self ) -> List [ WordSequence ]: \"\"\"Get a list of word sequences (either pure or comma separated) separated by \"and\" ```text spaces := SPACE SPACE* ; words := word (spaces word)* comma_sep_seq := words spaces? COMMA spaces? words (spaces? COMMA spaces? words)* ; pure_seq := words sequence := pure_seq | comma_sep_seq ; sequences := sequence (\"and\" sequence)* ; ``` \"\"\" sequences : List [ WordSequence ] = [] words = [[]] capitalizations = [[]] group = 0 def make_seq (): if group == 0 : sequences . append ( PureWordSequence ( words [ 0 ], capitalizations [ 0 ])) else : sequences . append ( CommaSeparatedWordSequence ( words , capitalizations )) self . skip_empty () while self . current_token . type != AuthorTokenType . EOS : if self . current_token . type in [ AuthorTokenType . LETTER , AuthorTokenType . BRACEDITEM , AuthorTokenType . SPECIALCHAR ]: word , capitalization = self . word () if word . lower () == 'and' : make_seq () words = [[]] capitalizations = [[]] else : words [ group ] . append ( word ) capitalizations [ group ] . append ( capitalization ) self . skip_empty () elif self . current_token . type == AuthorTokenType . COMMA : group += 1 if group > 3 : raise AuthorParserSyntaxError ( 'got {} , which is more than 2 comma!' . format ( self . current_token )) words . append ([]) capitalizations . append ([]) self . next () self . skip_empty () # catch last make_seq () return sequences skip_empty ( self ) \u00a4 Skip spaces Source code in pybibtex/authors.py def skip_empty ( self ): \"\"\"Skip spaces \"\"\" while self . current_token . type == AuthorTokenType . SPACE : self . next () word ( self ) \u00a4 Get a word and its capitalization, according to http://tug.ctan.org/info/bibtex/tamethebeast/ttb_en.pdf: -1 if the word is caseless, 0 if it is lowercase, 1 if it is uppercase A BRACEDITEM has no case, but a special character has the one of its argument c := LETTER | BRACEDITEM | SPECIALCHAR ; word := c c* ; Source code in pybibtex/authors.py def word ( self ) -> Tuple [ str , int ]: \"\"\"Get a word and its capitalization, according to http://tug.ctan.org/info/bibtex/tamethebeast/ttb_en.pdf: + ``-1`` if the word is caseless, + ``0`` if it is lowercase, + ``1`` if it is uppercase A ``BRACEDITEM`` has no case, but a special character has the one of its argument ```text c := LETTER | BRACEDITEM | SPECIALCHAR ; word := c c* ; ``` \"\"\" check_capitalization = True capitalization = - 1 word = '' while self . current_token . type in [ AuthorTokenType . LETTER , AuthorTokenType . BRACEDITEM , AuthorTokenType . SPECIALCHAR ]: value = self . current_token . value if check_capitalization : if self . current_token . type == AuthorTokenType . LETTER and value . isalpha (): capitalization = 1 if value . upper () == value else 0 check_capitalization = False elif self . current_token . type == AuthorTokenType . SPECIALCHAR : # quick and dirty look for argument i = 2 # skip command name if value [ i ] . isalpha (): while i < len ( value ) and value [ i ] . isalpha (): i += 1 # take next alpha (should be the argument) while i < len ( value ) and not value [ i ] . isalnum (): i += 1 if i < len ( value ): capitalization = 1 if value [ i ] . upper () == value [ i ] else 0 check_capitalization = False word += value self . next () return word , capitalization AuthorToken \u00a4 __init__ ( self , typ_ , value , position =- 1 ) special \u00a4 Initialize the object Source code in pybibtex/authors.py def __init__ ( self , typ_ : AuthorTokenType , value : str , position : int = - 1 ): \"\"\"Initialize the object \"\"\" self . type = typ_ self . value = value self . position = position AuthorTokenType \u00a4 An enumeration. CommaSeparatedWordSequence \u00a4 __init__ ( self , seq , capitalization ) special \u00a4 Initialize the object Source code in pybibtex/authors.py def __init__ ( self , seq : List [ List [ str ]], capitalization : List [ List [ int ]]): \"\"\"Initialize the object \"\"\" self . groups = seq self . num_fields = len ( self . groups ) self . capitalizations = capitalization transform ( self ) \u00a4 Transform a sequence written in \"comma form\" into an author: The last group is always first ; If they are 3 groups, the second is jr ; Put the last word of the first group in last . Then, as long as they are uppercase or caseless, the last words of the first group are in last (stops at the first lowercase one); The remaining of the first group is in von ; Source code in pybibtex/authors.py def transform ( self ) -> Author : \"\"\"Transform a sequence written in \"comma form\" into an author: 1. The last group is always `first`; 2. If they are 3 groups, the second is `jr`; 2. Put the last word of the first group in `last`. Then, as long as they are uppercase or caseless, the last words of the first group are in `last` (stops at the first lowercase one); 3. The remaining of the first group is in `von`; \"\"\" first = WordSequence . to_sentence ( self . groups [ - 1 ]) jr = '' if self . num_fields == 2 else WordSequence . to_sentence ( self . groups [ - 2 ]) words = self . groups [ 0 ] capitalizations = self . capitalizations [ 0 ] start_last = len ( words ) - 1 while start_last > 0 : if capitalizations [ start_last - 1 ] in [ 1 , - 1 ]: start_last -= 1 else : break last = WordSequence . to_sentence ( words [ start_last :]) if start_last > 0 : von = ' ' . join ( words [: start_last ]) else : von = '' return Author ( first , last , von = von , jr = jr ) PureWordSequence \u00a4 __init__ ( self , words , capitalization ) special \u00a4 Initialize the object Source code in pybibtex/authors.py def __init__ ( self , words : List [ str ], capitalization : List [ int ]): \"\"\"Initialize the object \"\"\" self . words = words self . capitalizations = capitalization transform ( self ) \u00a4 Transform a sequence written in \"natural form\" (no comma) into an author: The last word is always last ; As long as they are uppercase or caseless, the first words are in first (stops at the first lowercase one); The remaining is in von ; There is no jr part. Source code in pybibtex/authors.py def transform ( self ) -> Author : \"\"\"Transform a sequence written in \"natural form\" (no comma) into an author: 1. The last word is always `last`; 2. As long as they are uppercase or caseless, the first words are in `first` (stops at the first lowercase one); 3. The remaining is in `von`; 4. There is no `jr` part. \"\"\" von = '' jr = '' words = self . words # get first end_first = 0 while end_first < len ( words ) - 1 : if self . capitalizations [ end_first ] in [ 1 , - 1 ]: end_first += 1 else : break first = WordSequence . to_sentence ( words [: end_first ]) # get last start_last = len ( words ) - 1 while start_last > end_first : if self . capitalizations [ start_last - 1 ] in [ 1 , - 1 ]: start_last -= 1 else : break last = WordSequence . to_sentence ( words [ start_last :]) # get von, if any if end_first != start_last : von = WordSequence . to_sentence ( words [ end_first : start_last ]) return Author ( first , last , von = von , jr = jr ) WordSequence \u00a4 transform ( self ) \u00a4 Transform the word sequence into an author Source code in pybibtex/authors.py def transform ( self ) -> Author : \"\"\"Transform the word sequence into an author \"\"\" raise NotImplementedError ()","title":"Authors"},{"location":"code_reference/authors/#pybibtex.authors.Author","text":"Represent an author You can access: its last name, with author.last (always not empty), its first name, with author.first (may be empty), its \"von\" part, with author.von (may be empty), its \"jr\" part, with author.jr (may be empty).","title":"Author"},{"location":"code_reference/authors/#pybibtex.authors.Author.__init__","text":"Initialize the object Source code in pybibtex/authors.py def __init__ ( self , first : str , last : str , von : str = '' , jr : str = '' ): \"\"\"Initialize the object \"\"\" if not last : raise Exception ( 'last must not be empty' ) self . first = first #: author first name (may be empty) self . last = last #: author last name (never empty) self . von = von #: author \"von\" part (may be empty) self . jr = jr #: author \"jr\" part (may be empty)","title":"__init__()"},{"location":"code_reference/authors/#pybibtex.authors.Author.__str__","text":"Return the author in the \"comma\" form (since it is the only one which handle \"jr\") Source code in pybibtex/authors.py def __str__ ( self ): \"\"\"Return the author in the \"comma\" form (since it is the only one which handle \"jr\") \"\"\" return ' {}{} , {}{} ' . format ( '' if not self . von else self . von + ' ' , self . last , '' if not self . jr else ' {} , ' . format ( self . jr ), self . first )","title":"__str__()"},{"location":"code_reference/authors/#pybibtex.authors.AuthorParserSyntaxError","text":"Exception raised when the parser issued an error","title":"AuthorParserSyntaxError"},{"location":"code_reference/authors/#pybibtex.authors.AuthorsParser","text":"Parser to extract the authors","title":"AuthorsParser"},{"location":"code_reference/authors/#pybibtex.authors.AuthorsParser.__init__","text":"Initialize the object Parameters: Name Type Description Default inp str input string required Source code in pybibtex/authors.py def __init__ ( self , inp : str ): \"\"\"Initialize the object Parameters: inp: input string \"\"\" self . input = inp self . current_token : AuthorToken = None self . tokenizer = self . tokenize () self . next ()","title":"__init__()"},{"location":"code_reference/authors/#pybibtex.authors.AuthorsParser.authors","text":"Get the list of Author Source code in pybibtex/authors.py def authors ( self ) -> List [ Author ]: \"\"\"Get the list of `Author` \"\"\" return [ s . transform () for s in self . sequences ()]","title":"authors()"},{"location":"code_reference/authors/#pybibtex.authors.AuthorsParser.next","text":"Go to next token Source code in pybibtex/authors.py def next ( self ): \"\"\"Go to next token \"\"\" try : self . current_token = next ( self . tokenizer ) except StopIteration : self . current_token = AuthorToken ( AuthorTokenType . EOS , ' \\0 ' )","title":"next()"},{"location":"code_reference/authors/#pybibtex.authors.AuthorsParser.sequences","text":"Get a list of word sequences (either pure or comma separated) separated by \"and\" spaces := SPACE SPACE* ; words := word (spaces word)* comma_sep_seq := words spaces? COMMA spaces? words (spaces? COMMA spaces? words)* ; pure_seq := words sequence := pure_seq | comma_sep_seq ; sequences := sequence (\"and\" sequence)* ; Source code in pybibtex/authors.py def sequences ( self ) -> List [ WordSequence ]: \"\"\"Get a list of word sequences (either pure or comma separated) separated by \"and\" ```text spaces := SPACE SPACE* ; words := word (spaces word)* comma_sep_seq := words spaces? COMMA spaces? words (spaces? COMMA spaces? words)* ; pure_seq := words sequence := pure_seq | comma_sep_seq ; sequences := sequence (\"and\" sequence)* ; ``` \"\"\" sequences : List [ WordSequence ] = [] words = [[]] capitalizations = [[]] group = 0 def make_seq (): if group == 0 : sequences . append ( PureWordSequence ( words [ 0 ], capitalizations [ 0 ])) else : sequences . append ( CommaSeparatedWordSequence ( words , capitalizations )) self . skip_empty () while self . current_token . type != AuthorTokenType . EOS : if self . current_token . type in [ AuthorTokenType . LETTER , AuthorTokenType . BRACEDITEM , AuthorTokenType . SPECIALCHAR ]: word , capitalization = self . word () if word . lower () == 'and' : make_seq () words = [[]] capitalizations = [[]] else : words [ group ] . append ( word ) capitalizations [ group ] . append ( capitalization ) self . skip_empty () elif self . current_token . type == AuthorTokenType . COMMA : group += 1 if group > 3 : raise AuthorParserSyntaxError ( 'got {} , which is more than 2 comma!' . format ( self . current_token )) words . append ([]) capitalizations . append ([]) self . next () self . skip_empty () # catch last make_seq () return sequences","title":"sequences()"},{"location":"code_reference/authors/#pybibtex.authors.AuthorsParser.skip_empty","text":"Skip spaces Source code in pybibtex/authors.py def skip_empty ( self ): \"\"\"Skip spaces \"\"\" while self . current_token . type == AuthorTokenType . SPACE : self . next ()","title":"skip_empty()"},{"location":"code_reference/authors/#pybibtex.authors.AuthorsParser.word","text":"Get a word and its capitalization, according to http://tug.ctan.org/info/bibtex/tamethebeast/ttb_en.pdf: -1 if the word is caseless, 0 if it is lowercase, 1 if it is uppercase A BRACEDITEM has no case, but a special character has the one of its argument c := LETTER | BRACEDITEM | SPECIALCHAR ; word := c c* ; Source code in pybibtex/authors.py def word ( self ) -> Tuple [ str , int ]: \"\"\"Get a word and its capitalization, according to http://tug.ctan.org/info/bibtex/tamethebeast/ttb_en.pdf: + ``-1`` if the word is caseless, + ``0`` if it is lowercase, + ``1`` if it is uppercase A ``BRACEDITEM`` has no case, but a special character has the one of its argument ```text c := LETTER | BRACEDITEM | SPECIALCHAR ; word := c c* ; ``` \"\"\" check_capitalization = True capitalization = - 1 word = '' while self . current_token . type in [ AuthorTokenType . LETTER , AuthorTokenType . BRACEDITEM , AuthorTokenType . SPECIALCHAR ]: value = self . current_token . value if check_capitalization : if self . current_token . type == AuthorTokenType . LETTER and value . isalpha (): capitalization = 1 if value . upper () == value else 0 check_capitalization = False elif self . current_token . type == AuthorTokenType . SPECIALCHAR : # quick and dirty look for argument i = 2 # skip command name if value [ i ] . isalpha (): while i < len ( value ) and value [ i ] . isalpha (): i += 1 # take next alpha (should be the argument) while i < len ( value ) and not value [ i ] . isalnum (): i += 1 if i < len ( value ): capitalization = 1 if value [ i ] . upper () == value [ i ] else 0 check_capitalization = False word += value self . next () return word , capitalization","title":"word()"},{"location":"code_reference/authors/#pybibtex.authors.AuthorToken","text":"","title":"AuthorToken"},{"location":"code_reference/authors/#pybibtex.authors.AuthorToken.__init__","text":"Initialize the object Source code in pybibtex/authors.py def __init__ ( self , typ_ : AuthorTokenType , value : str , position : int = - 1 ): \"\"\"Initialize the object \"\"\" self . type = typ_ self . value = value self . position = position","title":"__init__()"},{"location":"code_reference/authors/#pybibtex.authors.AuthorTokenType","text":"An enumeration.","title":"AuthorTokenType"},{"location":"code_reference/authors/#pybibtex.authors.CommaSeparatedWordSequence","text":"","title":"CommaSeparatedWordSequence"},{"location":"code_reference/authors/#pybibtex.authors.CommaSeparatedWordSequence.__init__","text":"Initialize the object Source code in pybibtex/authors.py def __init__ ( self , seq : List [ List [ str ]], capitalization : List [ List [ int ]]): \"\"\"Initialize the object \"\"\" self . groups = seq self . num_fields = len ( self . groups ) self . capitalizations = capitalization","title":"__init__()"},{"location":"code_reference/authors/#pybibtex.authors.CommaSeparatedWordSequence.transform","text":"Transform a sequence written in \"comma form\" into an author: The last group is always first ; If they are 3 groups, the second is jr ; Put the last word of the first group in last . Then, as long as they are uppercase or caseless, the last words of the first group are in last (stops at the first lowercase one); The remaining of the first group is in von ; Source code in pybibtex/authors.py def transform ( self ) -> Author : \"\"\"Transform a sequence written in \"comma form\" into an author: 1. The last group is always `first`; 2. If they are 3 groups, the second is `jr`; 2. Put the last word of the first group in `last`. Then, as long as they are uppercase or caseless, the last words of the first group are in `last` (stops at the first lowercase one); 3. The remaining of the first group is in `von`; \"\"\" first = WordSequence . to_sentence ( self . groups [ - 1 ]) jr = '' if self . num_fields == 2 else WordSequence . to_sentence ( self . groups [ - 2 ]) words = self . groups [ 0 ] capitalizations = self . capitalizations [ 0 ] start_last = len ( words ) - 1 while start_last > 0 : if capitalizations [ start_last - 1 ] in [ 1 , - 1 ]: start_last -= 1 else : break last = WordSequence . to_sentence ( words [ start_last :]) if start_last > 0 : von = ' ' . join ( words [: start_last ]) else : von = '' return Author ( first , last , von = von , jr = jr )","title":"transform()"},{"location":"code_reference/authors/#pybibtex.authors.PureWordSequence","text":"","title":"PureWordSequence"},{"location":"code_reference/authors/#pybibtex.authors.PureWordSequence.__init__","text":"Initialize the object Source code in pybibtex/authors.py def __init__ ( self , words : List [ str ], capitalization : List [ int ]): \"\"\"Initialize the object \"\"\" self . words = words self . capitalizations = capitalization","title":"__init__()"},{"location":"code_reference/authors/#pybibtex.authors.PureWordSequence.transform","text":"Transform a sequence written in \"natural form\" (no comma) into an author: The last word is always last ; As long as they are uppercase or caseless, the first words are in first (stops at the first lowercase one); The remaining is in von ; There is no jr part. Source code in pybibtex/authors.py def transform ( self ) -> Author : \"\"\"Transform a sequence written in \"natural form\" (no comma) into an author: 1. The last word is always `last`; 2. As long as they are uppercase or caseless, the first words are in `first` (stops at the first lowercase one); 3. The remaining is in `von`; 4. There is no `jr` part. \"\"\" von = '' jr = '' words = self . words # get first end_first = 0 while end_first < len ( words ) - 1 : if self . capitalizations [ end_first ] in [ 1 , - 1 ]: end_first += 1 else : break first = WordSequence . to_sentence ( words [: end_first ]) # get last start_last = len ( words ) - 1 while start_last > end_first : if self . capitalizations [ start_last - 1 ] in [ 1 , - 1 ]: start_last -= 1 else : break last = WordSequence . to_sentence ( words [ start_last :]) # get von, if any if end_first != start_last : von = WordSequence . to_sentence ( words [ end_first : start_last ]) return Author ( first , last , von = von , jr = jr )","title":"transform()"},{"location":"code_reference/authors/#pybibtex.authors.WordSequence","text":"","title":"WordSequence"},{"location":"code_reference/authors/#pybibtex.authors.WordSequence.transform","text":"Transform the word sequence into an author Source code in pybibtex/authors.py def transform ( self ) -> Author : \"\"\"Transform the word sequence into an author \"\"\" raise NotImplementedError ()","title":"transform()"},{"location":"code_reference/bibliography/","text":"Example of usage: from pybibtex.parser import Parser bibtex = \"\"\" @string(bibtex = \"BiB{\\TeX}\") @misc{bibtexing, author = \"Oren Patashnik\", title = bibtex # \"ing\", year = 1988 } \"\"\" database = Parser ( bibtex ) . parse () item = database [ 'bibtexing' ] print ( item [ 'title' ]) # prints \"BiB{\\TeX}ing print ( item [ 'year' ]) # prints 1988 Database \u00a4 Database of bibliographic items You can access the item directly by their citation key using bibliography['citation-key'] . Note The cite_key are considered to be case insensitive in lookup. __str__ ( self ) special \u00a4 Outputs bibtex database Source code in pybibtex/bibliography.py def __str__ ( self ) -> str : \"\"\"Outputs bibtex database \"\"\" return ' \\n ' . join ( str ( item ) for item in self . db . values ()) Item \u00a4 Bibliography item. You can access the fields directly using item['key'] . Note item_type and cite_key are case technically case insensitive, but the actual cite_key is kept __init__ ( self , cite_key , item_type = 'article' , fields = None ) special \u00a4 Initialize the object Source code in pybibtex/bibliography.py def __init__ ( self , cite_key : str , item_type : str = 'article' , fields : dict = None ): \"\"\"Initialize the object\"\"\" self . cite_key = cite_key #: citation key self . item_type = item_type . lower () #: item type (article, book, ...) self . fields = fields __str__ ( self ) special \u00a4 Outputs bibtex item Source code in pybibtex/bibliography.py def __str__ ( self ) -> str : \"\"\"Outputs bibtex item \"\"\" return '@ {} {{ {} , \\n {} \\n }}' . format ( self . item_type , self . cite_key , ', \\n ' . join ( ' {} = {{ {} }}' . format ( k , v ) for k , v in self . fields . items ())) authors ( self , possible_fields = ( 'author' , 'Author' , 'AUTHOR' )) \u00a4 Get a list of Authors . Parameters: Name Type Description Default possible_fields Iterable[str] looks for the fields in possible_fields to get the authors, stops when found. ('author', 'Author', 'AUTHOR') Source code in pybibtex/bibliography.py def authors ( self , possible_fields : Iterable [ str ] = ( 'author' , 'Author' , 'AUTHOR' )) -> List [ Author ]: \"\"\"Get a list of ``Authors``. Parameters: possible_fields: looks for the fields in ``possible_fields`` to get the authors, stops when found. \"\"\" for f in possible_fields : if f in self . fields : return AuthorsParser ( self . fields [ f ]) . authors () return []","title":"Bibliography"},{"location":"code_reference/bibliography/#pybibtex.bibliography.Database","text":"Database of bibliographic items You can access the item directly by their citation key using bibliography['citation-key'] . Note The cite_key are considered to be case insensitive in lookup.","title":"Database"},{"location":"code_reference/bibliography/#pybibtex.bibliography.Database.__str__","text":"Outputs bibtex database Source code in pybibtex/bibliography.py def __str__ ( self ) -> str : \"\"\"Outputs bibtex database \"\"\" return ' \\n ' . join ( str ( item ) for item in self . db . values ())","title":"__str__()"},{"location":"code_reference/bibliography/#pybibtex.bibliography.Item","text":"Bibliography item. You can access the fields directly using item['key'] . Note item_type and cite_key are case technically case insensitive, but the actual cite_key is kept","title":"Item"},{"location":"code_reference/bibliography/#pybibtex.bibliography.Item.__init__","text":"Initialize the object Source code in pybibtex/bibliography.py def __init__ ( self , cite_key : str , item_type : str = 'article' , fields : dict = None ): \"\"\"Initialize the object\"\"\" self . cite_key = cite_key #: citation key self . item_type = item_type . lower () #: item type (article, book, ...) self . fields = fields","title":"__init__()"},{"location":"code_reference/bibliography/#pybibtex.bibliography.Item.__str__","text":"Outputs bibtex item Source code in pybibtex/bibliography.py def __str__ ( self ) -> str : \"\"\"Outputs bibtex item \"\"\" return '@ {} {{ {} , \\n {} \\n }}' . format ( self . item_type , self . cite_key , ', \\n ' . join ( ' {} = {{ {} }}' . format ( k , v ) for k , v in self . fields . items ()))","title":"__str__()"},{"location":"code_reference/bibliography/#pybibtex.bibliography.Item.authors","text":"Get a list of Authors . Parameters: Name Type Description Default possible_fields Iterable[str] looks for the fields in possible_fields to get the authors, stops when found. ('author', 'Author', 'AUTHOR') Source code in pybibtex/bibliography.py def authors ( self , possible_fields : Iterable [ str ] = ( 'author' , 'Author' , 'AUTHOR' )) -> List [ Author ]: \"\"\"Get a list of ``Authors``. Parameters: possible_fields: looks for the fields in ``possible_fields`` to get the authors, stops when found. \"\"\" for f in possible_fields : if f in self . fields : return AuthorsParser ( self . fields [ f ]) . authors () return []","title":"authors()"},{"location":"code_reference/parser/","text":"Example of usage: from pybibtex.parser import Parser bibtex = \"\"\" @string(bibtex = \"BiB{\\TeX}\") @misc{bibtexing, author = \"Oren Patashnik\", title = bibtex # \"ing\", year = 1988 } \"\"\" parser = Parser ( bibtex ) database = parser . parse () # access to item assert 'bibtexing' in database # you can access the string variables after `parse()` print ( parser . string_variables [ 'bibtex' ]) # prints \"BiB{\\TeX}\" Lexer \u00a4 next ( self ) \u00a4 Go to next token Source code in pybibtex/parser.py def next ( self ): \"\"\"Go to next token \"\"\" self . position += 1 if self . position >= len ( self . input ): self . current_char = ' \\0 ' else : self . current_char = self . input [ self . position ] Parser \u00a4 Parser for the bibliography in BiBTeX format __init__ ( self , inp ) special \u00a4 Initialize the object Parameters: Name Type Description Default inp str string containing the BiBTeX database required Source code in pybibtex/parser.py def __init__ ( self , inp : str ): \"\"\"Initialize the object Parameters: inp: string containing the BiBTeX database \"\"\" self . lexer = Lexer ( inp ) self . tokenizer = self . lexer . tokenize () self . current_token : Token = None # month are defined by default self . string_variables = { 'jan' : 'january' , 'feb' : 'february' , 'mar' : 'march' , 'apr' : 'april' , 'may' : 'may' , 'jun' : 'june' , 'jul' : 'july' , 'aug' : 'august' , 'sep' : 'september' , 'oct' : 'october' , 'nov' : 'november' , 'dec' : 'december' } self . next () comment ( self ) \u00a4 Skip whatever remains of the line Source code in pybibtex/parser.py def comment ( self ): \"\"\"Skip whatever remains of the line \"\"\" while self . current_token . type not in [ TokenType . NL , TokenType . EOS ]: self . next () database ( self ) \u00a4 The BibTeX format is more or less defined as bibtex := (item | string_var | comment)*; with string_var := AT 'string' (LCBRACE inside_string_var RCBRACE | LPAR inside_string_var RPAR) ; item := AT literal (LCBRACE inside_item RCBRACE | LPAR inside_item RPAR) ; comment := (AT 'comment' CHAR* NL | CHAR*) (it is missing the @preamble instruction). Source code in pybibtex/parser.py def database ( self ) -> Database : \"\"\" The BibTeX format is more or less defined as ```text bibtex := (item | string_var | comment)*; ``` with ```text string_var := AT 'string' (LCBRACE inside_string_var RCBRACE | LPAR inside_string_var RPAR) ; item := AT literal (LCBRACE inside_item RCBRACE | LPAR inside_item RPAR) ; comment := (AT 'comment' CHAR* NL | CHAR*) ``` (it is missing the `@preamble` instruction). \"\"\" db = {} self . skip_any_but_item () # go to the next @ while self . current_token . type != TokenType . EOS : self . eat ( TokenType . AT ) # get type item_type = self . literal () self . skip_empty () if item_type . lower () == 'comment' : self . comment () else : # get opening if self . current_token . type not in OPENINGS : raise ParserSyntaxError ( 'expected OPENINGS, got {} ' . format ( self . current_token )) opening = self . current_token . type closing = { TokenType . LPAR : TokenType . RPAR , TokenType . LCBRACE : TokenType . RCBRACE }[ opening ] self . next () self . skip_empty () # go inside if item_type . lower () == 'string' : self . inside_string_var () else : item = self . inside_item ( item_type ) db [ item . cite_key . lower ()] = item self . skip_empty () self . eat ( closing ) self . skip_any_but_item () self . eat ( TokenType . EOS ) return Database ( db ) field ( self ) \u00a4 Get a field: field := key EQUAL value ; Source code in pybibtex/parser.py def field ( self ) -> Tuple [ str , str ]: \"\"\" Get a field: ```text field := key EQUAL value ; ``` \"\"\" # get key key = self . key () # eat EQUAL self . skip_empty () self . eat ( TokenType . EQUAL ) self . skip_empty () # get value and return return key , self . value () inside_item ( self , item_type ) \u00a4 Get an item: inside_item := key COMMA (field (COMMA field)*)? COMMA? Source code in pybibtex/parser.py def inside_item ( self , item_type : str ) -> Item : \"\"\"Get an item: ```text inside_item := key COMMA (field (COMMA field)*)? COMMA? ``` \"\"\" # get key item_citekey = self . key () # eat COMMA self . skip_empty () self . eat ( TokenType . COMMA ) self . skip_empty () # get fields fields = {} while True : if self . current_token . type == TokenType . COMMA : # empty value, skip self . next () continue elif self . current_token . type in [ TokenType . RCBRACE , TokenType . RPAR ]: # that's the end of it! break try : k , v = self . field () except ParserSyntaxError as e : raise ParserSyntaxError ( 'while parsing {} , {} ' . format ( item_citekey , e )) fields [ k ] = v self . skip_empty () if self . current_token . type != TokenType . COMMA : break else : self . next () self . skip_empty () return Item ( cite_key = item_citekey , item_type = item_type , fields = fields ) inside_string_var ( self ) \u00a4 Defines a string variable: inside_string_var := key EQUAL value ; Note key is maybe a bit broadly defined (is : valid?) Source code in pybibtex/parser.py def inside_string_var ( self ): \"\"\"Defines a string variable: ```text inside_string_var := key EQUAL value ; ``` !!! note `key` is maybe a bit broadly defined (is `:` valid?) \"\"\" # get placeholder placeholder = self . literal () # eat EQUAL self . skip_empty () self . eat ( TokenType . EQUAL ) self . skip_empty () # get value and define value = self . value () self . string_variables [ placeholder ] = value key ( self ) \u00a4 Get a key, key := [a-zA-Z0-9_\\-:]* Note That means that a key can start by an integer or : (that should not be a problem) Source code in pybibtex/parser.py def key ( self ) -> str : \"\"\"Get a key, ```text key := [a-zA-Z0-9_\\\\-:]* ``` !!! note That means that a key can start by an integer or ``:`` (that should not be a problem) \"\"\" if self . current_token . type != TokenType . CHAR or not IS_KEY . match ( self . current_token . value ): raise ParserSyntaxError ( 'expected literal, got {} ' . format ( self . current_token )) citekey = '' while self . current_token . type == TokenType . CHAR and IS_KEY . match ( self . current_token . value ): citekey += self . current_token . value self . next () return citekey literal ( self ) \u00a4 Get a literal, as literal := [a-aA-Z_] [a-zA-Z0-9_]* Note It cannot start by an integer, for obvious reasons. Source code in pybibtex/parser.py def literal ( self ) -> str : \"\"\"Get a literal, as ```text literal := [a-aA-Z_] [a-zA-Z0-9_]* ``` !!! note It cannot start by an integer, for obvious reasons. \"\"\" if self . current_token . type != TokenType . CHAR or not IS_LITERAL_BEG . match ( self . current_token . value ): raise ParserSyntaxError ( 'expected literal, got {} ' . format ( self . current_token )) literal = self . current_token . value self . next () while self . current_token . type == TokenType . CHAR and IS_LITERAL . match ( self . current_token . value ): literal += self . current_token . value self . next () return literal next ( self ) \u00a4 Get next token Source code in pybibtex/parser.py def next ( self ): \"\"\"Get next token\"\"\" self . _next () skip_any_but_item ( self ) \u00a4 Skip anything until the next @, since it is considered to be a comment Source code in pybibtex/parser.py def skip_any_but_item ( self ): \"\"\"Skip anything until the next @, since it is considered to be a comment \"\"\" while self . current_token . type not in [ TokenType . AT , TokenType . EOS ]: self . next () skip_empty ( self ) \u00a4 Skip spaces, newlines and comments Source code in pybibtex/parser.py def skip_empty ( self ): \"\"\"Skip spaces, newlines and comments \"\"\" while self . current_token . type in [ TokenType . SPACE , TokenType . NL ]: self . next () string_part ( self ) \u00a4 Get an actual string. Note that for a quote to be escaped, it must be inside braces. Which means that braces must match, even in quote. INTEGER := [0-9] sl := CHAR* | QUOTE | LBRACE sl* RBRACE ; string_part := literal | INTEGER INTEGER* | LBRACE sl* RBRACE | QQUOTE (CHAR* | LCBRACE sl* RCBRACE)* QUOTE ; Source code in pybibtex/parser.py def string_part ( self ) -> str : \"\"\"Get an actual string. Note that for a quote to be escaped, it must be inside braces. Which means that braces **must** match, even in quote. ```text INTEGER := [0-9] sl := CHAR* | QUOTE | LBRACE sl* RBRACE ; string_part := literal | INTEGER INTEGER* | LBRACE sl* RBRACE | QQUOTE (CHAR* | LCBRACE sl* RCBRACE)* QUOTE ; ``` \"\"\" if self . current_token . type == TokenType . CHAR : if self . current_token . value . isnumeric (): # its a pure integer value = '' while self . current_token . type == TokenType . CHAR and self . current_token . value . isnumeric (): value += self . current_token . value self . next () else : # ... it is a literal, then lit = self . literal () try : value = self . string_variables [ lit ] except KeyError : raise ParserSyntaxError ( ' {} is not defined' . format ( lit )) elif self . current_token . type in [ TokenType . LCBRACE , TokenType . QUOTE ]: opening_char = self . current_token . type self . next () value = '' brace_level = 1 if opening_char == TokenType . LCBRACE else 0 while True : if self . current_token . type == TokenType . LCBRACE : brace_level += 1 elif self . current_token . type == TokenType . RCBRACE : brace_level -= 1 if opening_char == TokenType . LCBRACE and brace_level == 0 : self . next () break elif self . current_token . type == TokenType . QUOTE : if opening_char == TokenType . QUOTE and brace_level == 0 : self . next () break elif self . current_token . type == TokenType . EOS : raise ParserSyntaxError ( 'got {} while parsing string' . format ( self . current_token )) value += self . current_token . value self . next () else : raise ParserSyntaxError ( 'expected string, got {} ' . format ( self . current_token )) return value value ( self ) \u00a4 A value is a string, but different stuffs can be concatenated. value := string_part (POUND string_part)* ; Note It means that integer can be concatenated, deal with it. Source code in pybibtex/parser.py def value ( self ) -> str : \"\"\"A value is a string, but different stuffs can be concatenated. ```text value := string_part (POUND string_part)* ; ``` !!! note It means that integer can be concatenated, deal with it. \"\"\" value = self . string_part () # concatenate? self . skip_empty () while self . current_token . type == TokenType . POUND : # eat POUND self . next () self . skip_empty () # get next value value += self . string_part () self . skip_empty () # ok, done return value TokenType \u00a4 An enumeration.","title":"BibTeX Parser"},{"location":"code_reference/parser/#pybibtex.parser.Lexer","text":"","title":"Lexer"},{"location":"code_reference/parser/#pybibtex.parser.Lexer.next","text":"Go to next token Source code in pybibtex/parser.py def next ( self ): \"\"\"Go to next token \"\"\" self . position += 1 if self . position >= len ( self . input ): self . current_char = ' \\0 ' else : self . current_char = self . input [ self . position ]","title":"next()"},{"location":"code_reference/parser/#pybibtex.parser.Parser","text":"Parser for the bibliography in BiBTeX format","title":"Parser"},{"location":"code_reference/parser/#pybibtex.parser.Parser.__init__","text":"Initialize the object Parameters: Name Type Description Default inp str string containing the BiBTeX database required Source code in pybibtex/parser.py def __init__ ( self , inp : str ): \"\"\"Initialize the object Parameters: inp: string containing the BiBTeX database \"\"\" self . lexer = Lexer ( inp ) self . tokenizer = self . lexer . tokenize () self . current_token : Token = None # month are defined by default self . string_variables = { 'jan' : 'january' , 'feb' : 'february' , 'mar' : 'march' , 'apr' : 'april' , 'may' : 'may' , 'jun' : 'june' , 'jul' : 'july' , 'aug' : 'august' , 'sep' : 'september' , 'oct' : 'october' , 'nov' : 'november' , 'dec' : 'december' } self . next ()","title":"__init__()"},{"location":"code_reference/parser/#pybibtex.parser.Parser.comment","text":"Skip whatever remains of the line Source code in pybibtex/parser.py def comment ( self ): \"\"\"Skip whatever remains of the line \"\"\" while self . current_token . type not in [ TokenType . NL , TokenType . EOS ]: self . next ()","title":"comment()"},{"location":"code_reference/parser/#pybibtex.parser.Parser.database","text":"The BibTeX format is more or less defined as bibtex := (item | string_var | comment)*; with string_var := AT 'string' (LCBRACE inside_string_var RCBRACE | LPAR inside_string_var RPAR) ; item := AT literal (LCBRACE inside_item RCBRACE | LPAR inside_item RPAR) ; comment := (AT 'comment' CHAR* NL | CHAR*) (it is missing the @preamble instruction). Source code in pybibtex/parser.py def database ( self ) -> Database : \"\"\" The BibTeX format is more or less defined as ```text bibtex := (item | string_var | comment)*; ``` with ```text string_var := AT 'string' (LCBRACE inside_string_var RCBRACE | LPAR inside_string_var RPAR) ; item := AT literal (LCBRACE inside_item RCBRACE | LPAR inside_item RPAR) ; comment := (AT 'comment' CHAR* NL | CHAR*) ``` (it is missing the `@preamble` instruction). \"\"\" db = {} self . skip_any_but_item () # go to the next @ while self . current_token . type != TokenType . EOS : self . eat ( TokenType . AT ) # get type item_type = self . literal () self . skip_empty () if item_type . lower () == 'comment' : self . comment () else : # get opening if self . current_token . type not in OPENINGS : raise ParserSyntaxError ( 'expected OPENINGS, got {} ' . format ( self . current_token )) opening = self . current_token . type closing = { TokenType . LPAR : TokenType . RPAR , TokenType . LCBRACE : TokenType . RCBRACE }[ opening ] self . next () self . skip_empty () # go inside if item_type . lower () == 'string' : self . inside_string_var () else : item = self . inside_item ( item_type ) db [ item . cite_key . lower ()] = item self . skip_empty () self . eat ( closing ) self . skip_any_but_item () self . eat ( TokenType . EOS ) return Database ( db )","title":"database()"},{"location":"code_reference/parser/#pybibtex.parser.Parser.field","text":"Get a field: field := key EQUAL value ; Source code in pybibtex/parser.py def field ( self ) -> Tuple [ str , str ]: \"\"\" Get a field: ```text field := key EQUAL value ; ``` \"\"\" # get key key = self . key () # eat EQUAL self . skip_empty () self . eat ( TokenType . EQUAL ) self . skip_empty () # get value and return return key , self . value ()","title":"field()"},{"location":"code_reference/parser/#pybibtex.parser.Parser.inside_item","text":"Get an item: inside_item := key COMMA (field (COMMA field)*)? COMMA? Source code in pybibtex/parser.py def inside_item ( self , item_type : str ) -> Item : \"\"\"Get an item: ```text inside_item := key COMMA (field (COMMA field)*)? COMMA? ``` \"\"\" # get key item_citekey = self . key () # eat COMMA self . skip_empty () self . eat ( TokenType . COMMA ) self . skip_empty () # get fields fields = {} while True : if self . current_token . type == TokenType . COMMA : # empty value, skip self . next () continue elif self . current_token . type in [ TokenType . RCBRACE , TokenType . RPAR ]: # that's the end of it! break try : k , v = self . field () except ParserSyntaxError as e : raise ParserSyntaxError ( 'while parsing {} , {} ' . format ( item_citekey , e )) fields [ k ] = v self . skip_empty () if self . current_token . type != TokenType . COMMA : break else : self . next () self . skip_empty () return Item ( cite_key = item_citekey , item_type = item_type , fields = fields )","title":"inside_item()"},{"location":"code_reference/parser/#pybibtex.parser.Parser.inside_string_var","text":"Defines a string variable: inside_string_var := key EQUAL value ; Note key is maybe a bit broadly defined (is : valid?) Source code in pybibtex/parser.py def inside_string_var ( self ): \"\"\"Defines a string variable: ```text inside_string_var := key EQUAL value ; ``` !!! note `key` is maybe a bit broadly defined (is `:` valid?) \"\"\" # get placeholder placeholder = self . literal () # eat EQUAL self . skip_empty () self . eat ( TokenType . EQUAL ) self . skip_empty () # get value and define value = self . value () self . string_variables [ placeholder ] = value","title":"inside_string_var()"},{"location":"code_reference/parser/#pybibtex.parser.Parser.key","text":"Get a key, key := [a-zA-Z0-9_\\-:]* Note That means that a key can start by an integer or : (that should not be a problem) Source code in pybibtex/parser.py def key ( self ) -> str : \"\"\"Get a key, ```text key := [a-zA-Z0-9_\\\\-:]* ``` !!! note That means that a key can start by an integer or ``:`` (that should not be a problem) \"\"\" if self . current_token . type != TokenType . CHAR or not IS_KEY . match ( self . current_token . value ): raise ParserSyntaxError ( 'expected literal, got {} ' . format ( self . current_token )) citekey = '' while self . current_token . type == TokenType . CHAR and IS_KEY . match ( self . current_token . value ): citekey += self . current_token . value self . next () return citekey","title":"key()"},{"location":"code_reference/parser/#pybibtex.parser.Parser.literal","text":"Get a literal, as literal := [a-aA-Z_] [a-zA-Z0-9_]* Note It cannot start by an integer, for obvious reasons. Source code in pybibtex/parser.py def literal ( self ) -> str : \"\"\"Get a literal, as ```text literal := [a-aA-Z_] [a-zA-Z0-9_]* ``` !!! note It cannot start by an integer, for obvious reasons. \"\"\" if self . current_token . type != TokenType . CHAR or not IS_LITERAL_BEG . match ( self . current_token . value ): raise ParserSyntaxError ( 'expected literal, got {} ' . format ( self . current_token )) literal = self . current_token . value self . next () while self . current_token . type == TokenType . CHAR and IS_LITERAL . match ( self . current_token . value ): literal += self . current_token . value self . next () return literal","title":"literal()"},{"location":"code_reference/parser/#pybibtex.parser.Parser.next","text":"Get next token Source code in pybibtex/parser.py def next ( self ): \"\"\"Get next token\"\"\" self . _next ()","title":"next()"},{"location":"code_reference/parser/#pybibtex.parser.Parser.skip_any_but_item","text":"Skip anything until the next @, since it is considered to be a comment Source code in pybibtex/parser.py def skip_any_but_item ( self ): \"\"\"Skip anything until the next @, since it is considered to be a comment \"\"\" while self . current_token . type not in [ TokenType . AT , TokenType . EOS ]: self . next ()","title":"skip_any_but_item()"},{"location":"code_reference/parser/#pybibtex.parser.Parser.skip_empty","text":"Skip spaces, newlines and comments Source code in pybibtex/parser.py def skip_empty ( self ): \"\"\"Skip spaces, newlines and comments \"\"\" while self . current_token . type in [ TokenType . SPACE , TokenType . NL ]: self . next ()","title":"skip_empty()"},{"location":"code_reference/parser/#pybibtex.parser.Parser.string_part","text":"Get an actual string. Note that for a quote to be escaped, it must be inside braces. Which means that braces must match, even in quote. INTEGER := [0-9] sl := CHAR* | QUOTE | LBRACE sl* RBRACE ; string_part := literal | INTEGER INTEGER* | LBRACE sl* RBRACE | QQUOTE (CHAR* | LCBRACE sl* RCBRACE)* QUOTE ; Source code in pybibtex/parser.py def string_part ( self ) -> str : \"\"\"Get an actual string. Note that for a quote to be escaped, it must be inside braces. Which means that braces **must** match, even in quote. ```text INTEGER := [0-9] sl := CHAR* | QUOTE | LBRACE sl* RBRACE ; string_part := literal | INTEGER INTEGER* | LBRACE sl* RBRACE | QQUOTE (CHAR* | LCBRACE sl* RCBRACE)* QUOTE ; ``` \"\"\" if self . current_token . type == TokenType . CHAR : if self . current_token . value . isnumeric (): # its a pure integer value = '' while self . current_token . type == TokenType . CHAR and self . current_token . value . isnumeric (): value += self . current_token . value self . next () else : # ... it is a literal, then lit = self . literal () try : value = self . string_variables [ lit ] except KeyError : raise ParserSyntaxError ( ' {} is not defined' . format ( lit )) elif self . current_token . type in [ TokenType . LCBRACE , TokenType . QUOTE ]: opening_char = self . current_token . type self . next () value = '' brace_level = 1 if opening_char == TokenType . LCBRACE else 0 while True : if self . current_token . type == TokenType . LCBRACE : brace_level += 1 elif self . current_token . type == TokenType . RCBRACE : brace_level -= 1 if opening_char == TokenType . LCBRACE and brace_level == 0 : self . next () break elif self . current_token . type == TokenType . QUOTE : if opening_char == TokenType . QUOTE and brace_level == 0 : self . next () break elif self . current_token . type == TokenType . EOS : raise ParserSyntaxError ( 'got {} while parsing string' . format ( self . current_token )) value += self . current_token . value self . next () else : raise ParserSyntaxError ( 'expected string, got {} ' . format ( self . current_token )) return value","title":"string_part()"},{"location":"code_reference/parser/#pybibtex.parser.Parser.value","text":"A value is a string, but different stuffs can be concatenated. value := string_part (POUND string_part)* ; Note It means that integer can be concatenated, deal with it. Source code in pybibtex/parser.py def value ( self ) -> str : \"\"\"A value is a string, but different stuffs can be concatenated. ```text value := string_part (POUND string_part)* ; ``` !!! note It means that integer can be concatenated, deal with it. \"\"\" value = self . string_part () # concatenate? self . skip_empty () while self . current_token . type == TokenType . POUND : # eat POUND self . next () self . skip_empty () # get next value value += self . string_part () self . skip_empty () # ok, done return value","title":"value()"},{"location":"code_reference/parser/#pybibtex.parser.TokenType","text":"An enumeration.","title":"TokenType"},{"location":"code_reference/utf8/","text":"Example of usage: from pybibtex.latexutf8 import utf8decode , utf8encode # prints \"\\'Emile de la Tourbi\\`ere\" print ( utf8decode ( '\u00c9mile de la Tourbi\u00e8re' )) # prints \"\u00c9mile de la Tourbi\u00e8re\" print ( utf8encode ( \" \\\\ 'Emile de la Tourbi \\\\ `ere\" )) UTF8EncodeException \u00a4 Exception raised when there is an error in the input string utf8decode ( inp ) \u00a4 Replace dec:lared UTF-8 character by their LaTeX equivalent Parameters: Name Type Description Default inp str string containing special UTF-8 characters required Returns: Type Description str A string with the LaTeX equivalent of UTF-8 characters Source code in pybibtex/latexutf8.py def utf8decode ( inp : str ) -> str : \"\"\"Replace dec:lared UTF-8 character by their LaTeX equivalent Parameters: inp: string containing special UTF-8 characters Returns: A string with the LaTeX equivalent of UTF-8 characters \"\"\" return inp . translate ( TRANSLATION_TABLE ) utf8encode ( inp ) \u00a4 Replace LaTeX characters by their UTF-8 equivalent Parameters: Name Type Description Default inp str string containing LaTeX macros required Returns: Type Description str A string with the UTF-8 equivalent of the macros Source code in pybibtex/latexutf8.py def utf8encode ( inp : str ) -> str : \"\"\"Replace LaTeX characters by their UTF-8 equivalent Parameters: inp: string containing LaTeX macros Returns: A string with the UTF-8 equivalent of the macros \"\"\" return LtxUTF8Parser ( inp , REVERSE_TRANSLATION_TABLE ) . transform ()","title":"UTF-8 handling"},{"location":"code_reference/utf8/#pybibtex.latexutf8.UTF8EncodeException","text":"Exception raised when there is an error in the input string","title":"UTF8EncodeException"},{"location":"code_reference/utf8/#pybibtex.latexutf8.utf8decode","text":"Replace dec:lared UTF-8 character by their LaTeX equivalent Parameters: Name Type Description Default inp str string containing special UTF-8 characters required Returns: Type Description str A string with the LaTeX equivalent of UTF-8 characters Source code in pybibtex/latexutf8.py def utf8decode ( inp : str ) -> str : \"\"\"Replace dec:lared UTF-8 character by their LaTeX equivalent Parameters: inp: string containing special UTF-8 characters Returns: A string with the LaTeX equivalent of UTF-8 characters \"\"\" return inp . translate ( TRANSLATION_TABLE )","title":"utf8decode()"},{"location":"code_reference/utf8/#pybibtex.latexutf8.utf8encode","text":"Replace LaTeX characters by their UTF-8 equivalent Parameters: Name Type Description Default inp str string containing LaTeX macros required Returns: Type Description str A string with the UTF-8 equivalent of the macros Source code in pybibtex/latexutf8.py def utf8encode ( inp : str ) -> str : \"\"\"Replace LaTeX characters by their UTF-8 equivalent Parameters: inp: string containing LaTeX macros Returns: A string with the UTF-8 equivalent of the macros \"\"\" return LtxUTF8Parser ( inp , REVERSE_TRANSLATION_TABLE ) . transform ()","title":"utf8encode()"}]}